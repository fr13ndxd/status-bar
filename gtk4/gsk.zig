// This file is auto-generated by zig-gir-ffi
const gsk = @This();
pub const pango_cairo = @import("pango_cairo");
pub const freetype2 = @import("freetype2");
pub const glib = @import("glib");
pub const gdk_pixbuf = @import("gdk_pixbuf");
pub const harf_buzz = @import("harf_buzz");
pub const gmodule = @import("gmodule");
pub const cairo = @import("cairo");
pub const graphene = @import("graphene");
pub const gobject = @import("gobject");
pub const pango = @import("pango");
pub const gdk = @import("gdk");
pub const gio = @import("gio");
pub const core = @import("core");
const std = @import("std");
const config = core.config;
/// Enum [BlendMode](https://docs.gtk.org/gsk4/enum.BlendMode.html)
pub const BlendMode = enum(u32) {
    default = 0,
    multiply = 1,
    screen = 2,
    overlay = 3,
    darken = 4,
    lighten = 5,
    color_dodge = 6,
    color_burn = 7,
    hard_light = 8,
    soft_light = 9,
    difference = 10,
    exclusion = 11,
    color = 12,
    hue = 13,
    saturation = 14,
    luminosity = 15,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_blend_mode_get_type" });
        return cFn();
    }
};
/// Class [BlendNode](https://docs.gtk.org/gsk4/class.BlendNode.html)
pub const BlendNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.BlendNode.new.html)
    pub fn new(_bottom: *gsk.RenderNode, _top: *gsk.RenderNode, _blend_mode: gsk.BlendMode) *BlendNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.RenderNode, gsk.BlendMode) callconv(.c) *BlendNode, .{ .name = "gsk_blend_node_new" });
        const ret = cFn(_bottom, _top, _blend_mode);
        return ret;
    }
    /// method [get_blend_mode](https://docs.gtk.org/gsk4/method.BlendNode.get_blend_mode.html)
    pub fn getBlendMode(self: *BlendNode) gsk.BlendMode {
        const cFn = @extern(*const fn (*BlendNode) callconv(.c) gsk.BlendMode, .{ .name = "gsk_blend_node_get_blend_mode" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_bottom_child](https://docs.gtk.org/gsk4/method.BlendNode.get_bottom_child.html)
    pub fn getBottomChild(self: *BlendNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*BlendNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_blend_node_get_bottom_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_top_child](https://docs.gtk.org/gsk4/method.BlendNode.get_top_child.html)
    pub fn getTopChild(self: *BlendNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*BlendNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_blend_node_get_top_child" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_blend_node_get_type" });
        return cFn();
    }
};
/// Class [BlurNode](https://docs.gtk.org/gsk4/class.BlurNode.html)
pub const BlurNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.BlurNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _radius: f32) *BlurNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, f32) callconv(.c) *BlurNode, .{ .name = "gsk_blur_node_new" });
        const ret = cFn(_child, _radius);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.BlurNode.get_child.html)
    pub fn getChild(self: *BlurNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*BlurNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_blur_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_radius](https://docs.gtk.org/gsk4/method.BlurNode.get_radius.html)
    pub fn getRadius(self: *BlurNode) f32 {
        const cFn = @extern(*const fn (*BlurNode) callconv(.c) f32, .{ .name = "gsk_blur_node_get_radius" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_blur_node_get_type" });
        return cFn();
    }
};
/// Class [BorderNode](https://docs.gtk.org/gsk4/class.BorderNode.html)
pub const BorderNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.BorderNode.new.html)
    pub fn new(_outline: *gsk.RoundedRect, _border_width: *[4]f32, _border_color: *[4]gdk.RGBA) *BorderNode {
        const cFn = @extern(*const fn (*gsk.RoundedRect, *[4]f32, *[4]gdk.RGBA) callconv(.c) *BorderNode, .{ .name = "gsk_border_node_new" });
        const ret = cFn(_outline, _border_width, _border_color);
        return ret;
    }
    /// method [get_colors](https://docs.gtk.org/gsk4/method.BorderNode.get_colors.html)
    pub fn getColors(self: *BorderNode) *gdk.RGBA {
        const cFn = @extern(*const fn (*BorderNode) callconv(.c) *gdk.RGBA, .{ .name = "gsk_border_node_get_colors" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_outline](https://docs.gtk.org/gsk4/method.BorderNode.get_outline.html)
    pub fn getOutline(self: *BorderNode) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*BorderNode) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_border_node_get_outline" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_widths](https://docs.gtk.org/gsk4/method.BorderNode.get_widths.html)
    pub fn getWidths(self: *BorderNode) *[4]f32 {
        const cFn = @extern(*const fn (*BorderNode) callconv(.c) *[4]f32, .{ .name = "gsk_border_node_get_widths" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_border_node_get_type" });
        return cFn();
    }
};
/// Class [BroadwayRenderer](https://docs.gtk.org/gsk4/class.BroadwayRenderer.html)
pub const BroadwayRenderer = opaque {
    pub const Parent = gsk.Renderer;
    pub const Class = gsk.BroadwayRendererClass;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.BroadwayRenderer.new.html)
    pub fn new() *BroadwayRenderer {
        const cFn = @extern(*const fn () callconv(.c) *BroadwayRenderer, .{ .name = "gsk_broadway_renderer_new" });
        const ret = cFn();
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_broadway_renderer_get_type" });
        return cFn();
    }
};
pub const BroadwayRendererClass = opaque {};
/// Class [CairoNode](https://docs.gtk.org/gsk4/class.CairoNode.html)
pub const CairoNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.CairoNode.new.html)
    pub fn new(_bounds: *graphene.Rect) *CairoNode {
        const cFn = @extern(*const fn (*graphene.Rect) callconv(.c) *CairoNode, .{ .name = "gsk_cairo_node_new" });
        const ret = cFn(_bounds);
        return ret;
    }
    /// method [get_draw_context](https://docs.gtk.org/gsk4/method.CairoNode.get_draw_context.html)
    pub fn getDrawContext(self: *CairoNode) *cairo.Context {
        const cFn = @extern(*const fn (*CairoNode) callconv(.c) *cairo.Context, .{ .name = "gsk_cairo_node_get_draw_context" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_surface](https://docs.gtk.org/gsk4/method.CairoNode.get_surface.html)
    pub fn getSurface(self: *CairoNode) *cairo.Surface {
        const cFn = @extern(*const fn (*CairoNode) callconv(.c) *cairo.Surface, .{ .name = "gsk_cairo_node_get_surface" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_cairo_node_get_type" });
        return cFn();
    }
};
/// Class [CairoRenderer](https://docs.gtk.org/gsk4/class.CairoRenderer.html)
pub const CairoRenderer = opaque {
    pub const Parent = gsk.Renderer;
    pub const Class = gsk.CairoRendererClass;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.CairoRenderer.new.html)
    pub fn new() *CairoRenderer {
        const cFn = @extern(*const fn () callconv(.c) *CairoRenderer, .{ .name = "gsk_cairo_renderer_new" });
        const ret = cFn();
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_cairo_renderer_get_type" });
        return cFn();
    }
};
pub const CairoRendererClass = opaque {};
/// Class [ClipNode](https://docs.gtk.org/gsk4/class.ClipNode.html)
pub const ClipNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ClipNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _clip: *graphene.Rect) *ClipNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *graphene.Rect) callconv(.c) *ClipNode, .{ .name = "gsk_clip_node_new" });
        const ret = cFn(_child, _clip);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.ClipNode.get_child.html)
    pub fn getChild(self: *ClipNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*ClipNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_clip_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_clip](https://docs.gtk.org/gsk4/method.ClipNode.get_clip.html)
    pub fn getClip(self: *ClipNode) *graphene.Rect {
        const cFn = @extern(*const fn (*ClipNode) callconv(.c) *graphene.Rect, .{ .name = "gsk_clip_node_get_clip" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_clip_node_get_type" });
        return cFn();
    }
};
/// Class [ColorMatrixNode](https://docs.gtk.org/gsk4/class.ColorMatrixNode.html)
pub const ColorMatrixNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ColorMatrixNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _color_matrix: *graphene.Matrix, _color_offset: *graphene.Vec4) *ColorMatrixNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *graphene.Matrix, *graphene.Vec4) callconv(.c) *ColorMatrixNode, .{ .name = "gsk_color_matrix_node_new" });
        const ret = cFn(_child, _color_matrix, _color_offset);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.ColorMatrixNode.get_child.html)
    pub fn getChild(self: *ColorMatrixNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*ColorMatrixNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_color_matrix_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_color_matrix](https://docs.gtk.org/gsk4/method.ColorMatrixNode.get_color_matrix.html)
    pub fn getColorMatrix(self: *ColorMatrixNode) *graphene.Matrix {
        const cFn = @extern(*const fn (*ColorMatrixNode) callconv(.c) *graphene.Matrix, .{ .name = "gsk_color_matrix_node_get_color_matrix" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_color_offset](https://docs.gtk.org/gsk4/method.ColorMatrixNode.get_color_offset.html)
    pub fn getColorOffset(self: *ColorMatrixNode) *graphene.Vec4 {
        const cFn = @extern(*const fn (*ColorMatrixNode) callconv(.c) *graphene.Vec4, .{ .name = "gsk_color_matrix_node_get_color_offset" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_color_matrix_node_get_type" });
        return cFn();
    }
};
/// Class [ColorNode](https://docs.gtk.org/gsk4/class.ColorNode.html)
pub const ColorNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ColorNode.new.html)
    pub fn new(_rgba: *gdk.RGBA, _bounds: *graphene.Rect) *ColorNode {
        const cFn = @extern(*const fn (*gdk.RGBA, *graphene.Rect) callconv(.c) *ColorNode, .{ .name = "gsk_color_node_new" });
        const ret = cFn(_rgba, _bounds);
        return ret;
    }
    /// method [get_color](https://docs.gtk.org/gsk4/method.ColorNode.get_color.html)
    pub fn getColor(self: *ColorNode) *gdk.RGBA {
        const cFn = @extern(*const fn (*ColorNode) callconv(.c) *gdk.RGBA, .{ .name = "gsk_color_node_get_color" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_color_node_get_type" });
        return cFn();
    }
};
/// Struct [ColorStop](https://docs.gtk.org/gsk4/struct.ColorStop.html)
pub const ColorStop = extern struct {
    offset: f32,
    color: gdk.RGBA,
};
/// Class [ConicGradientNode](https://docs.gtk.org/gsk4/class.ConicGradientNode.html)
pub const ConicGradientNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ConicGradientNode.new.html)
    pub fn new(_bounds: *graphene.Rect, _center: *graphene.Point, _rotation: f32, _color_stopss: []gsk.ColorStop) *ConicGradientNode {
        const _color_stops = _color_stopss.ptr;
        const _n_color_stops: u64 = @intCast(_color_stopss.len);
        const cFn = @extern(*const fn (*graphene.Rect, *graphene.Point, f32, [*]gsk.ColorStop, u64) callconv(.c) *ConicGradientNode, .{ .name = "gsk_conic_gradient_node_new" });
        const ret = cFn(_bounds, _center, _rotation, _color_stops, _n_color_stops);
        return ret;
    }
    /// method [get_angle](https://docs.gtk.org/gsk4/method.ConicGradientNode.get_angle.html)
    pub fn getAngle(self: *ConicGradientNode) f32 {
        const cFn = @extern(*const fn (*ConicGradientNode) callconv(.c) f32, .{ .name = "gsk_conic_gradient_node_get_angle" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_center](https://docs.gtk.org/gsk4/method.ConicGradientNode.get_center.html)
    pub fn getCenter(self: *ConicGradientNode) *graphene.Point {
        const cFn = @extern(*const fn (*ConicGradientNode) callconv(.c) *graphene.Point, .{ .name = "gsk_conic_gradient_node_get_center" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_color_stops](https://docs.gtk.org/gsk4/method.ConicGradientNode.get_color_stops.html)
    pub fn getColorStops(self: *ConicGradientNode) struct {
        ret: [*]gsk.ColorStop,
        n_stops: u64,
    } {
        var n_stops_out: u64 = undefined;
        const _n_stops = &n_stops_out;
        const cFn = @extern(*const fn (*ConicGradientNode, ?*u64) callconv(.c) [*]gsk.ColorStop, .{ .name = "gsk_conic_gradient_node_get_color_stops" });
        const ret = cFn(self, _n_stops);
        return .{ .ret = ret, .n_stops = n_stops_out };
    }
    /// method [get_n_color_stops](https://docs.gtk.org/gsk4/method.ConicGradientNode.get_n_color_stops.html)
    pub fn getNColorStops(self: *ConicGradientNode) u64 {
        const cFn = @extern(*const fn (*ConicGradientNode) callconv(.c) u64, .{ .name = "gsk_conic_gradient_node_get_n_color_stops" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_rotation](https://docs.gtk.org/gsk4/method.ConicGradientNode.get_rotation.html)
    pub fn getRotation(self: *ConicGradientNode) f32 {
        const cFn = @extern(*const fn (*ConicGradientNode) callconv(.c) f32, .{ .name = "gsk_conic_gradient_node_get_rotation" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_conic_gradient_node_get_type" });
        return cFn();
    }
};
/// Class [ContainerNode](https://docs.gtk.org/gsk4/class.ContainerNode.html)
pub const ContainerNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ContainerNode.new.html)
    pub fn new(_childrens: []*gsk.RenderNode) *ContainerNode {
        const _children = _childrens.ptr;
        const _n_children: u32 = @intCast(_childrens.len);
        const cFn = @extern(*const fn ([*]*gsk.RenderNode, u32) callconv(.c) *ContainerNode, .{ .name = "gsk_container_node_new" });
        const ret = cFn(_children, _n_children);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.ContainerNode.get_child.html)
    pub fn getChild(self: *ContainerNode, _idx: u32) *gsk.RenderNode {
        const cFn = @extern(*const fn (*ContainerNode, u32) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_container_node_get_child" });
        const ret = cFn(self, _idx);
        return ret;
    }
    /// method [get_n_children](https://docs.gtk.org/gsk4/method.ContainerNode.get_n_children.html)
    pub fn getNChildren(self: *ContainerNode) u32 {
        const cFn = @extern(*const fn (*ContainerNode) callconv(.c) u32, .{ .name = "gsk_container_node_get_n_children" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_container_node_get_type" });
        return cFn();
    }
};
/// Enum [Corner](https://docs.gtk.org/gsk4/enum.Corner.html)
pub const Corner = enum(u32) {
    top_left = 0,
    top_right = 1,
    bottom_right = 2,
    bottom_left = 3,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_corner_get_type" });
        return cFn();
    }
};
/// Class [CrossFadeNode](https://docs.gtk.org/gsk4/class.CrossFadeNode.html)
pub const CrossFadeNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.CrossFadeNode.new.html)
    pub fn new(_start: *gsk.RenderNode, _end: *gsk.RenderNode, _progress: f32) *CrossFadeNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.RenderNode, f32) callconv(.c) *CrossFadeNode, .{ .name = "gsk_cross_fade_node_new" });
        const ret = cFn(_start, _end, _progress);
        return ret;
    }
    /// method [get_end_child](https://docs.gtk.org/gsk4/method.CrossFadeNode.get_end_child.html)
    pub fn getEndChild(self: *CrossFadeNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*CrossFadeNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_cross_fade_node_get_end_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_progress](https://docs.gtk.org/gsk4/method.CrossFadeNode.get_progress.html)
    pub fn getProgress(self: *CrossFadeNode) f32 {
        const cFn = @extern(*const fn (*CrossFadeNode) callconv(.c) f32, .{ .name = "gsk_cross_fade_node_get_progress" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_start_child](https://docs.gtk.org/gsk4/method.CrossFadeNode.get_start_child.html)
    pub fn getStartChild(self: *CrossFadeNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*CrossFadeNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_cross_fade_node_get_start_child" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_cross_fade_node_get_type" });
        return cFn();
    }
};
/// Class [DebugNode](https://docs.gtk.org/gsk4/class.DebugNode.html)
pub const DebugNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.DebugNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _message: [*:0]const u8) *DebugNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, [*:0]const u8) callconv(.c) *DebugNode, .{ .name = "gsk_debug_node_new" });
        const ret = cFn(_child, _message);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.DebugNode.get_child.html)
    pub fn getChild(self: *DebugNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*DebugNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_debug_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_message](https://docs.gtk.org/gsk4/method.DebugNode.get_message.html)
    pub fn getMessage(self: *DebugNode) [*:0]u8 {
        const cFn = @extern(*const fn (*DebugNode) callconv(.c) [*:0]u8, .{ .name = "gsk_debug_node_get_message" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_debug_node_get_type" });
        return cFn();
    }
};
/// Class [FillNode](https://docs.gtk.org/gsk4/class.FillNode.html)
pub const FillNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.FillNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _path: *gsk.Path, _fill_rule: gsk.FillRule) *FillNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.Path, gsk.FillRule) callconv(.c) *FillNode, .{ .name = "gsk_fill_node_new" });
        const ret = cFn(_child, _path, _fill_rule);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.FillNode.get_child.html)
    pub fn getChild(self: *FillNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*FillNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_fill_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_fill_rule](https://docs.gtk.org/gsk4/method.FillNode.get_fill_rule.html)
    pub fn getFillRule(self: *FillNode) gsk.FillRule {
        const cFn = @extern(*const fn (*FillNode) callconv(.c) gsk.FillRule, .{ .name = "gsk_fill_node_get_fill_rule" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_path](https://docs.gtk.org/gsk4/method.FillNode.get_path.html)
    pub fn getPath(self: *FillNode) *gsk.Path {
        const cFn = @extern(*const fn (*FillNode) callconv(.c) *gsk.Path, .{ .name = "gsk_fill_node_get_path" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_fill_node_get_type" });
        return cFn();
    }
};
/// Enum [FillRule](https://docs.gtk.org/gsk4/enum.FillRule.html)
pub const FillRule = enum(u32) {
    winding = 0,
    even_odd = 1,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_fill_rule_get_type" });
        return cFn();
    }
};
/// Class [GLRenderer](https://docs.gtk.org/gsk4/class.GLRenderer.html)
pub const GLRenderer = opaque {
    pub const Parent = gsk.Renderer;
    pub const Class = gsk.GLRendererClass;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.GLRenderer.new.html)
    pub fn new() *GLRenderer {
        const cFn = @extern(*const fn () callconv(.c) *GLRenderer, .{ .name = "gsk_gl_renderer_new" });
        const ret = cFn();
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_gl_renderer_get_type" });
        return cFn();
    }
};
pub const GLRendererClass = opaque {};
/// Class [GLShader](https://docs.gtk.org/gsk4/class.GLShader.html)
/// - property [resource](https://docs.gtk.org/gsk4/property.GLShader.resource.html): (r-) `[*:0]const u8`
/// - property [source](https://docs.gtk.org/gsk4/property.GLShader.source.html): (r-) `glib.Bytes`
pub const GLShader = opaque {
    pub const Parent = gobject.Object;
    pub const Class = gsk.GLShaderClass;
    /// ctor [new_from_bytes](https://docs.gtk.org/gsk4/ctor.GLShader.new_from_bytes.html)
    pub fn newFromBytes(_sourcecode: *glib.Bytes) *GLShader {
        const cFn = @extern(*const fn (*glib.Bytes) callconv(.c) *GLShader, .{ .name = "gsk_gl_shader_new_from_bytes" });
        const ret = cFn(_sourcecode);
        return ret;
    }
    /// ctor [new_from_resource](https://docs.gtk.org/gsk4/ctor.GLShader.new_from_resource.html)
    pub fn newFromResource(_resource_path: [*:0]const u8) *GLShader {
        const cFn = @extern(*const fn ([*:0]const u8) callconv(.c) *GLShader, .{ .name = "gsk_gl_shader_new_from_resource" });
        const ret = cFn(_resource_path);
        return ret;
    }
    /// method [compile](https://docs.gtk.org/gsk4/method.GLShader.compile.html)
    pub fn compile(self: *GLShader, _renderer: *gsk.Renderer, _error: *?*core.Error) error{GError}!bool {
        const cFn = @extern(*const fn (*GLShader, *gsk.Renderer, *?*core.Error) callconv(.c) bool, .{ .name = "gsk_gl_shader_compile" });
        const ret = cFn(self, _renderer, _error);
        if (_error.* != null) return error.GError;
        return ret;
    }
    /// method [find_uniform_by_name](https://docs.gtk.org/gsk4/method.GLShader.find_uniform_by_name.html)
    pub fn findUniformByName(self: *GLShader, _name: [*:0]const u8) i32 {
        const cFn = @extern(*const fn (*GLShader, [*:0]const u8) callconv(.c) i32, .{ .name = "gsk_gl_shader_find_uniform_by_name" });
        const ret = cFn(self, _name);
        return ret;
    }
    /// method [get_arg_bool](https://docs.gtk.org/gsk4/method.GLShader.get_arg_bool.html)
    pub fn getArgBool(self: *GLShader, _args: *glib.Bytes, _idx: i32) bool {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32) callconv(.c) bool, .{ .name = "gsk_gl_shader_get_arg_bool" });
        const ret = cFn(self, _args, _idx);
        return ret;
    }
    /// method [get_arg_float](https://docs.gtk.org/gsk4/method.GLShader.get_arg_float.html)
    pub fn getArgFloat(self: *GLShader, _args: *glib.Bytes, _idx: i32) f32 {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32) callconv(.c) f32, .{ .name = "gsk_gl_shader_get_arg_float" });
        const ret = cFn(self, _args, _idx);
        return ret;
    }
    /// method [get_arg_int](https://docs.gtk.org/gsk4/method.GLShader.get_arg_int.html)
    pub fn getArgInt(self: *GLShader, _args: *glib.Bytes, _idx: i32) i32 {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32) callconv(.c) i32, .{ .name = "gsk_gl_shader_get_arg_int" });
        const ret = cFn(self, _args, _idx);
        return ret;
    }
    /// method [get_arg_uint](https://docs.gtk.org/gsk4/method.GLShader.get_arg_uint.html)
    pub fn getArgUint(self: *GLShader, _args: *glib.Bytes, _idx: i32) u32 {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32) callconv(.c) u32, .{ .name = "gsk_gl_shader_get_arg_uint" });
        const ret = cFn(self, _args, _idx);
        return ret;
    }
    /// method [get_arg_vec2](https://docs.gtk.org/gsk4/method.GLShader.get_arg_vec2.html)
    pub fn getArgVec2(self: *GLShader, _args: *glib.Bytes, _idx: i32, _out_value: *graphene.Vec2) void {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32, *graphene.Vec2) callconv(.c) void, .{ .name = "gsk_gl_shader_get_arg_vec2" });
        const ret = cFn(self, _args, _idx, _out_value);
        return ret;
    }
    /// method [get_arg_vec3](https://docs.gtk.org/gsk4/method.GLShader.get_arg_vec3.html)
    pub fn getArgVec3(self: *GLShader, _args: *glib.Bytes, _idx: i32, _out_value: *graphene.Vec3) void {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32, *graphene.Vec3) callconv(.c) void, .{ .name = "gsk_gl_shader_get_arg_vec3" });
        const ret = cFn(self, _args, _idx, _out_value);
        return ret;
    }
    /// method [get_arg_vec4](https://docs.gtk.org/gsk4/method.GLShader.get_arg_vec4.html)
    pub fn getArgVec4(self: *GLShader, _args: *glib.Bytes, _idx: i32, _out_value: *graphene.Vec4) void {
        const cFn = @extern(*const fn (*GLShader, *glib.Bytes, i32, *graphene.Vec4) callconv(.c) void, .{ .name = "gsk_gl_shader_get_arg_vec4" });
        const ret = cFn(self, _args, _idx, _out_value);
        return ret;
    }
    /// method [get_args_size](https://docs.gtk.org/gsk4/method.GLShader.get_args_size.html)
    pub fn getArgsSize(self: *GLShader) u64 {
        const cFn = @extern(*const fn (*GLShader) callconv(.c) u64, .{ .name = "gsk_gl_shader_get_args_size" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_n_textures](https://docs.gtk.org/gsk4/method.GLShader.get_n_textures.html)
    pub fn getNTextures(self: *GLShader) i32 {
        const cFn = @extern(*const fn (*GLShader) callconv(.c) i32, .{ .name = "gsk_gl_shader_get_n_textures" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_n_uniforms](https://docs.gtk.org/gsk4/method.GLShader.get_n_uniforms.html)
    pub fn getNUniforms(self: *GLShader) i32 {
        const cFn = @extern(*const fn (*GLShader) callconv(.c) i32, .{ .name = "gsk_gl_shader_get_n_uniforms" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_resource](https://docs.gtk.org/gsk4/method.GLShader.get_resource.html)
    pub fn getResource(self: *GLShader) ?[*:0]u8 {
        const cFn = @extern(*const fn (*GLShader) callconv(.c) ?[*:0]u8, .{ .name = "gsk_gl_shader_get_resource" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_source](https://docs.gtk.org/gsk4/method.GLShader.get_source.html)
    pub fn getSource(self: *GLShader) *glib.Bytes {
        const cFn = @extern(*const fn (*GLShader) callconv(.c) *glib.Bytes, .{ .name = "gsk_gl_shader_get_source" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_uniform_name](https://docs.gtk.org/gsk4/method.GLShader.get_uniform_name.html)
    pub fn getUniformName(self: *GLShader, _idx: i32) [*:0]u8 {
        const cFn = @extern(*const fn (*GLShader, i32) callconv(.c) [*:0]u8, .{ .name = "gsk_gl_shader_get_uniform_name" });
        const ret = cFn(self, _idx);
        return ret;
    }
    /// method [get_uniform_offset](https://docs.gtk.org/gsk4/method.GLShader.get_uniform_offset.html)
    pub fn getUniformOffset(self: *GLShader, _idx: i32) i32 {
        const cFn = @extern(*const fn (*GLShader, i32) callconv(.c) i32, .{ .name = "gsk_gl_shader_get_uniform_offset" });
        const ret = cFn(self, _idx);
        return ret;
    }
    /// method [get_uniform_type](https://docs.gtk.org/gsk4/method.GLShader.get_uniform_type.html)
    pub fn getUniformType(self: *GLShader, _idx: i32) gsk.GLUniformType {
        const cFn = @extern(*const fn (*GLShader, i32) callconv(.c) gsk.GLUniformType, .{ .name = "gsk_gl_shader_get_uniform_type" });
        const ret = cFn(self, _idx);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_gl_shader_get_type" });
        return cFn();
    }
};
pub const GLShaderClass = extern struct {
    parent_class: gobject.ObjectClass,
};
/// Class [GLShaderNode](https://docs.gtk.org/gsk4/class.GLShaderNode.html)
pub const GLShaderNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.GLShaderNode.new.html)
    pub fn new(_shader: *gsk.GLShader, _bounds: *graphene.Rect, _args: *glib.Bytes, _childrens: []*gsk.RenderNode) *GLShaderNode {
        const _children = _childrens.ptr;
        const _n_children: u32 = @intCast(_childrens.len);
        const cFn = @extern(*const fn (*gsk.GLShader, *graphene.Rect, *glib.Bytes, ?[*]*gsk.RenderNode, u32) callconv(.c) *GLShaderNode, .{ .name = "gsk_gl_shader_node_new" });
        const ret = cFn(_shader, _bounds, _args, _children, _n_children);
        return ret;
    }
    /// method [get_args](https://docs.gtk.org/gsk4/method.GLShaderNode.get_args.html)
    pub fn getArgs(self: *GLShaderNode) *glib.Bytes {
        const cFn = @extern(*const fn (*GLShaderNode) callconv(.c) *glib.Bytes, .{ .name = "gsk_gl_shader_node_get_args" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.GLShaderNode.get_child.html)
    pub fn getChild(self: *GLShaderNode, _idx: u32) *gsk.RenderNode {
        const cFn = @extern(*const fn (*GLShaderNode, u32) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_gl_shader_node_get_child" });
        const ret = cFn(self, _idx);
        return ret;
    }
    /// method [get_n_children](https://docs.gtk.org/gsk4/method.GLShaderNode.get_n_children.html)
    pub fn getNChildren(self: *GLShaderNode) u32 {
        const cFn = @extern(*const fn (*GLShaderNode) callconv(.c) u32, .{ .name = "gsk_gl_shader_node_get_n_children" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_shader](https://docs.gtk.org/gsk4/method.GLShaderNode.get_shader.html)
    pub fn getShader(self: *GLShaderNode) *gsk.GLShader {
        const cFn = @extern(*const fn (*GLShaderNode) callconv(.c) *gsk.GLShader, .{ .name = "gsk_gl_shader_node_get_shader" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_gl_shader_node_get_type" });
        return cFn();
    }
};
/// Enum [GLUniformType](https://docs.gtk.org/gsk4/enum.GLUniformType.html)
pub const GLUniformType = enum(u32) {
    none = 0,
    float = 1,
    int = 2,
    uint = 3,
    bool = 4,
    vec2 = 5,
    vec3 = 6,
    vec4 = 7,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_gl_uniform_type_get_type" });
        return cFn();
    }
};
/// Class [InsetShadowNode](https://docs.gtk.org/gsk4/class.InsetShadowNode.html)
pub const InsetShadowNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.InsetShadowNode.new.html)
    pub fn new(_outline: *gsk.RoundedRect, _color: *gdk.RGBA, _dx: f32, _dy: f32, _spread: f32, _blur_radius: f32) *InsetShadowNode {
        const cFn = @extern(*const fn (*gsk.RoundedRect, *gdk.RGBA, f32, f32, f32, f32) callconv(.c) *InsetShadowNode, .{ .name = "gsk_inset_shadow_node_new" });
        const ret = cFn(_outline, _color, _dx, _dy, _spread, _blur_radius);
        return ret;
    }
    /// method [get_blur_radius](https://docs.gtk.org/gsk4/method.InsetShadowNode.get_blur_radius.html)
    pub fn getBlurRadius(self: *InsetShadowNode) f32 {
        const cFn = @extern(*const fn (*InsetShadowNode) callconv(.c) f32, .{ .name = "gsk_inset_shadow_node_get_blur_radius" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_color](https://docs.gtk.org/gsk4/method.InsetShadowNode.get_color.html)
    pub fn getColor(self: *InsetShadowNode) *gdk.RGBA {
        const cFn = @extern(*const fn (*InsetShadowNode) callconv(.c) *gdk.RGBA, .{ .name = "gsk_inset_shadow_node_get_color" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_dx](https://docs.gtk.org/gsk4/method.InsetShadowNode.get_dx.html)
    pub fn getDx(self: *InsetShadowNode) f32 {
        const cFn = @extern(*const fn (*InsetShadowNode) callconv(.c) f32, .{ .name = "gsk_inset_shadow_node_get_dx" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_dy](https://docs.gtk.org/gsk4/method.InsetShadowNode.get_dy.html)
    pub fn getDy(self: *InsetShadowNode) f32 {
        const cFn = @extern(*const fn (*InsetShadowNode) callconv(.c) f32, .{ .name = "gsk_inset_shadow_node_get_dy" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_outline](https://docs.gtk.org/gsk4/method.InsetShadowNode.get_outline.html)
    pub fn getOutline(self: *InsetShadowNode) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*InsetShadowNode) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_inset_shadow_node_get_outline" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_spread](https://docs.gtk.org/gsk4/method.InsetShadowNode.get_spread.html)
    pub fn getSpread(self: *InsetShadowNode) f32 {
        const cFn = @extern(*const fn (*InsetShadowNode) callconv(.c) f32, .{ .name = "gsk_inset_shadow_node_get_spread" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_inset_shadow_node_get_type" });
        return cFn();
    }
};
/// Enum [LineCap](https://docs.gtk.org/gsk4/enum.LineCap.html)
pub const LineCap = enum(u32) {
    butt = 0,
    round = 1,
    square = 2,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_line_cap_get_type" });
        return cFn();
    }
};
/// Enum [LineJoin](https://docs.gtk.org/gsk4/enum.LineJoin.html)
pub const LineJoin = enum(u32) {
    miter = 0,
    round = 1,
    bevel = 2,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_line_join_get_type" });
        return cFn();
    }
};
/// Class [LinearGradientNode](https://docs.gtk.org/gsk4/class.LinearGradientNode.html)
pub const LinearGradientNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.LinearGradientNode.new.html)
    pub fn new(_bounds: *graphene.Rect, _start: *graphene.Point, _end: *graphene.Point, _color_stopss: []gsk.ColorStop) *LinearGradientNode {
        const _color_stops = _color_stopss.ptr;
        const _n_color_stops: u64 = @intCast(_color_stopss.len);
        const cFn = @extern(*const fn (*graphene.Rect, *graphene.Point, *graphene.Point, [*]gsk.ColorStop, u64) callconv(.c) *LinearGradientNode, .{ .name = "gsk_linear_gradient_node_new" });
        const ret = cFn(_bounds, _start, _end, _color_stops, _n_color_stops);
        return ret;
    }
    /// method [get_color_stops](https://docs.gtk.org/gsk4/method.LinearGradientNode.get_color_stops.html)
    pub fn getColorStops(self: *LinearGradientNode) struct {
        ret: [*]gsk.ColorStop,
        n_stops: u64,
    } {
        var n_stops_out: u64 = undefined;
        const _n_stops = &n_stops_out;
        const cFn = @extern(*const fn (*LinearGradientNode, ?*u64) callconv(.c) [*]gsk.ColorStop, .{ .name = "gsk_linear_gradient_node_get_color_stops" });
        const ret = cFn(self, _n_stops);
        return .{ .ret = ret, .n_stops = n_stops_out };
    }
    /// method [get_end](https://docs.gtk.org/gsk4/method.LinearGradientNode.get_end.html)
    pub fn getEnd(self: *LinearGradientNode) *graphene.Point {
        const cFn = @extern(*const fn (*LinearGradientNode) callconv(.c) *graphene.Point, .{ .name = "gsk_linear_gradient_node_get_end" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_n_color_stops](https://docs.gtk.org/gsk4/method.LinearGradientNode.get_n_color_stops.html)
    pub fn getNColorStops(self: *LinearGradientNode) u64 {
        const cFn = @extern(*const fn (*LinearGradientNode) callconv(.c) u64, .{ .name = "gsk_linear_gradient_node_get_n_color_stops" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_start](https://docs.gtk.org/gsk4/method.LinearGradientNode.get_start.html)
    pub fn getStart(self: *LinearGradientNode) *graphene.Point {
        const cFn = @extern(*const fn (*LinearGradientNode) callconv(.c) *graphene.Point, .{ .name = "gsk_linear_gradient_node_get_start" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_linear_gradient_node_get_type" });
        return cFn();
    }
};
/// Enum [MaskMode](https://docs.gtk.org/gsk4/enum.MaskMode.html)
pub const MaskMode = enum(u32) {
    alpha = 0,
    inverted_alpha = 1,
    luminance = 2,
    inverted_luminance = 3,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_mask_mode_get_type" });
        return cFn();
    }
};
/// Class [MaskNode](https://docs.gtk.org/gsk4/class.MaskNode.html)
pub const MaskNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.MaskNode.new.html)
    pub fn new(_source: *gsk.RenderNode, _mask: *gsk.RenderNode, _mask_mode: gsk.MaskMode) *MaskNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.RenderNode, gsk.MaskMode) callconv(.c) *MaskNode, .{ .name = "gsk_mask_node_new" });
        const ret = cFn(_source, _mask, _mask_mode);
        return ret;
    }
    /// method [get_mask](https://docs.gtk.org/gsk4/method.MaskNode.get_mask.html)
    pub fn getMask(self: *MaskNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*MaskNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_mask_node_get_mask" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_mask_mode](https://docs.gtk.org/gsk4/method.MaskNode.get_mask_mode.html)
    pub fn getMaskMode(self: *MaskNode) gsk.MaskMode {
        const cFn = @extern(*const fn (*MaskNode) callconv(.c) gsk.MaskMode, .{ .name = "gsk_mask_node_get_mask_mode" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_source](https://docs.gtk.org/gsk4/method.MaskNode.get_source.html)
    pub fn getSource(self: *MaskNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*MaskNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_mask_node_get_source" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_mask_node_get_type" });
        return cFn();
    }
};
/// Class [NglRenderer](https://docs.gtk.org/gsk4/class.NglRenderer.html)
pub const NglRenderer = opaque {
    pub const Parent = gsk.Renderer;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.NglRenderer.new.html)
    pub fn new() *NglRenderer {
        const cFn = @extern(*const fn () callconv(.c) *NglRenderer, .{ .name = "gsk_ngl_renderer_new" });
        const ret = cFn();
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_ngl_renderer_get_type" });
        return cFn();
    }
};
/// Class [OpacityNode](https://docs.gtk.org/gsk4/class.OpacityNode.html)
pub const OpacityNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.OpacityNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _opacity: f32) *OpacityNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, f32) callconv(.c) *OpacityNode, .{ .name = "gsk_opacity_node_new" });
        const ret = cFn(_child, _opacity);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.OpacityNode.get_child.html)
    pub fn getChild(self: *OpacityNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*OpacityNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_opacity_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_opacity](https://docs.gtk.org/gsk4/method.OpacityNode.get_opacity.html)
    pub fn getOpacity(self: *OpacityNode) f32 {
        const cFn = @extern(*const fn (*OpacityNode) callconv(.c) f32, .{ .name = "gsk_opacity_node_get_opacity" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_opacity_node_get_type" });
        return cFn();
    }
};
/// Class [OutsetShadowNode](https://docs.gtk.org/gsk4/class.OutsetShadowNode.html)
pub const OutsetShadowNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.OutsetShadowNode.new.html)
    pub fn new(_outline: *gsk.RoundedRect, _color: *gdk.RGBA, _dx: f32, _dy: f32, _spread: f32, _blur_radius: f32) *OutsetShadowNode {
        const cFn = @extern(*const fn (*gsk.RoundedRect, *gdk.RGBA, f32, f32, f32, f32) callconv(.c) *OutsetShadowNode, .{ .name = "gsk_outset_shadow_node_new" });
        const ret = cFn(_outline, _color, _dx, _dy, _spread, _blur_radius);
        return ret;
    }
    /// method [get_blur_radius](https://docs.gtk.org/gsk4/method.OutsetShadowNode.get_blur_radius.html)
    pub fn getBlurRadius(self: *OutsetShadowNode) f32 {
        const cFn = @extern(*const fn (*OutsetShadowNode) callconv(.c) f32, .{ .name = "gsk_outset_shadow_node_get_blur_radius" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_color](https://docs.gtk.org/gsk4/method.OutsetShadowNode.get_color.html)
    pub fn getColor(self: *OutsetShadowNode) *gdk.RGBA {
        const cFn = @extern(*const fn (*OutsetShadowNode) callconv(.c) *gdk.RGBA, .{ .name = "gsk_outset_shadow_node_get_color" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_dx](https://docs.gtk.org/gsk4/method.OutsetShadowNode.get_dx.html)
    pub fn getDx(self: *OutsetShadowNode) f32 {
        const cFn = @extern(*const fn (*OutsetShadowNode) callconv(.c) f32, .{ .name = "gsk_outset_shadow_node_get_dx" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_dy](https://docs.gtk.org/gsk4/method.OutsetShadowNode.get_dy.html)
    pub fn getDy(self: *OutsetShadowNode) f32 {
        const cFn = @extern(*const fn (*OutsetShadowNode) callconv(.c) f32, .{ .name = "gsk_outset_shadow_node_get_dy" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_outline](https://docs.gtk.org/gsk4/method.OutsetShadowNode.get_outline.html)
    pub fn getOutline(self: *OutsetShadowNode) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*OutsetShadowNode) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_outset_shadow_node_get_outline" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_spread](https://docs.gtk.org/gsk4/method.OutsetShadowNode.get_spread.html)
    pub fn getSpread(self: *OutsetShadowNode) f32 {
        const cFn = @extern(*const fn (*OutsetShadowNode) callconv(.c) f32, .{ .name = "gsk_outset_shadow_node_get_spread" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_outset_shadow_node_get_type" });
        return cFn();
    }
};
/// callback [ParseErrorFunc](https://docs.gtk.org/gsk4/callback.ParseErrorFunc.html)
pub const ParseErrorFunc = *const fn (_start: *gsk.ParseLocation, _end: *gsk.ParseLocation, _error: *core.Error, _user_data: ?*anyopaque) callconv(.c) void;
/// Struct [ParseLocation](https://docs.gtk.org/gsk4/struct.ParseLocation.html)
pub const ParseLocation = extern struct {
    bytes: u64,
    chars: u64,
    lines: u64,
    line_bytes: u64,
    line_chars: u64,
};
/// Struct [Path](https://docs.gtk.org/gsk4/struct.Path.html)
pub const Path = opaque {
    /// method [foreach](https://docs.gtk.org/gsk4/method.Path.foreach.html)
    pub fn foreach(self: *Path, _flags: gsk.PathForeachFlags, func: anytype, func_args: anytype) bool {
        var closure_func = core.zig_closure(func, func_args, &.{ bool, gsk.PathOperation, *graphene.Point, u64, f32 });
        defer closure_func.deinit();
        const _func: gsk.PathForeachFunc = @ptrCast(closure_func.c_closure());
        const _user_data: ?*anyopaque = @ptrCast(closure_func.c_data());
        const cFn = @extern(*const fn (*Path, gsk.PathForeachFlags, gsk.PathForeachFunc, ?*anyopaque) callconv(.c) bool, .{ .name = "gsk_path_foreach" });
        const ret = cFn(self, _flags, _func, @ptrCast(_user_data));
        return ret;
    }
    /// method [get_bounds](https://docs.gtk.org/gsk4/method.Path.get_bounds.html)
    pub fn getBounds(self: *Path, _bounds: *graphene.Rect) bool {
        const cFn = @extern(*const fn (*Path, *graphene.Rect) callconv(.c) bool, .{ .name = "gsk_path_get_bounds" });
        const ret = cFn(self, _bounds);
        return ret;
    }
    /// method [get_closest_point](https://docs.gtk.org/gsk4/method.Path.get_closest_point.html)
    pub fn getClosestPoint(self: *Path, _point: *graphene.Point, _threshold: f32, _result: *gsk.PathPoint) ?f32 {
        var distance_out: f32 = undefined;
        const _distance = &distance_out;
        const cFn = @extern(*const fn (*Path, *graphene.Point, f32, *gsk.PathPoint, ?*f32) callconv(.c) bool, .{ .name = "gsk_path_get_closest_point" });
        const ret = cFn(self, _point, _threshold, _result, _distance);
        if (!ret) return null;
        return distance_out;
    }
    /// method [get_end_point](https://docs.gtk.org/gsk4/method.Path.get_end_point.html)
    pub fn getEndPoint(self: *Path, _result: *gsk.PathPoint) bool {
        const cFn = @extern(*const fn (*Path, *gsk.PathPoint) callconv(.c) bool, .{ .name = "gsk_path_get_end_point" });
        const ret = cFn(self, _result);
        return ret;
    }
    /// method [get_start_point](https://docs.gtk.org/gsk4/method.Path.get_start_point.html)
    pub fn getStartPoint(self: *Path, _result: *gsk.PathPoint) bool {
        const cFn = @extern(*const fn (*Path, *gsk.PathPoint) callconv(.c) bool, .{ .name = "gsk_path_get_start_point" });
        const ret = cFn(self, _result);
        return ret;
    }
    /// method [get_stroke_bounds](https://docs.gtk.org/gsk4/method.Path.get_stroke_bounds.html)
    pub fn getStrokeBounds(self: *Path, _stroke: *gsk.Stroke, _bounds: *graphene.Rect) bool {
        const cFn = @extern(*const fn (*Path, *gsk.Stroke, *graphene.Rect) callconv(.c) bool, .{ .name = "gsk_path_get_stroke_bounds" });
        const ret = cFn(self, _stroke, _bounds);
        return ret;
    }
    /// method [in_fill](https://docs.gtk.org/gsk4/method.Path.in_fill.html)
    pub fn inFill(self: *Path, _point: *graphene.Point, _fill_rule: gsk.FillRule) bool {
        const cFn = @extern(*const fn (*Path, *graphene.Point, gsk.FillRule) callconv(.c) bool, .{ .name = "gsk_path_in_fill" });
        const ret = cFn(self, _point, _fill_rule);
        return ret;
    }
    /// method [is_closed](https://docs.gtk.org/gsk4/method.Path.is_closed.html)
    pub fn isClosed(self: *Path) bool {
        const cFn = @extern(*const fn (*Path) callconv(.c) bool, .{ .name = "gsk_path_is_closed" });
        const ret = cFn(self);
        return ret;
    }
    /// method [is_empty](https://docs.gtk.org/gsk4/method.Path.is_empty.html)
    pub fn isEmpty(self: *Path) bool {
        const cFn = @extern(*const fn (*Path) callconv(.c) bool, .{ .name = "gsk_path_is_empty" });
        const ret = cFn(self);
        return ret;
    }
    /// method [print](https://docs.gtk.org/gsk4/method.Path.print.html)
    pub fn print(self: *Path, _string: *glib.String) void {
        const cFn = @extern(*const fn (*Path, *glib.String) callconv(.c) void, .{ .name = "gsk_path_print" });
        const ret = cFn(self, _string);
        return ret;
    }
    /// method [ref](https://docs.gtk.org/gsk4/method.Path.ref.html)
    pub fn ref(self: *Path) *gsk.Path {
        const cFn = @extern(*const fn (*Path) callconv(.c) *gsk.Path, .{ .name = "gsk_path_ref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [to_cairo](https://docs.gtk.org/gsk4/method.Path.to_cairo.html)
    pub fn toCairo(self: *Path, _cr: *cairo.Context) void {
        const cFn = @extern(*const fn (*Path, *cairo.Context) callconv(.c) void, .{ .name = "gsk_path_to_cairo" });
        const ret = cFn(self, _cr);
        return ret;
    }
    /// method [to_string](https://docs.gtk.org/gsk4/method.Path.to_string.html)
    pub fn toString(self: *Path) [*:0]u8 {
        const cFn = @extern(*const fn (*Path) callconv(.c) [*:0]u8, .{ .name = "gsk_path_to_string" });
        const ret = cFn(self);
        return ret;
    }
    /// method [unref](https://docs.gtk.org/gsk4/method.Path.unref.html)
    pub fn unref(self: *Path) void {
        const cFn = @extern(*const fn (*Path) callconv(.c) void, .{ .name = "gsk_path_unref" });
        const ret = cFn(self);
        return ret;
    }
    /// type func [parse](https://docs.gtk.org/gsk4/type_func.Path.parse.html)
    pub fn parse(_string: [*:0]const u8) ?*gsk.Path {
        const cFn = @extern(*const fn ([*:0]const u8) callconv(.c) ?*gsk.Path, .{ .name = "gsk_path_parse" });
        const ret = cFn(_string);
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_get_type" });
        return cFn();
    }
};
/// Struct [PathBuilder](https://docs.gtk.org/gsk4/struct.PathBuilder.html)
pub const PathBuilder = opaque {
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.PathBuilder.new.html)
    pub fn new() *PathBuilder {
        const cFn = @extern(*const fn () callconv(.c) *PathBuilder, .{ .name = "gsk_path_builder_new" });
        const ret = cFn();
        return ret;
    }
    /// method [add_cairo_path](https://docs.gtk.org/gsk4/method.PathBuilder.add_cairo_path.html)
    pub fn addCairoPath(self: *PathBuilder, _path: *cairo.Path) void {
        const cFn = @extern(*const fn (*PathBuilder, *cairo.Path) callconv(.c) void, .{ .name = "gsk_path_builder_add_cairo_path" });
        const ret = cFn(self, _path);
        return ret;
    }
    /// method [add_circle](https://docs.gtk.org/gsk4/method.PathBuilder.add_circle.html)
    pub fn addCircle(self: *PathBuilder, _center: *graphene.Point, _radius: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, *graphene.Point, f32) callconv(.c) void, .{ .name = "gsk_path_builder_add_circle" });
        const ret = cFn(self, _center, _radius);
        return ret;
    }
    /// method [add_layout](https://docs.gtk.org/gsk4/method.PathBuilder.add_layout.html)
    pub fn addLayout(self: *PathBuilder, _layout: *pango.Layout) void {
        const cFn = @extern(*const fn (*PathBuilder, *pango.Layout) callconv(.c) void, .{ .name = "gsk_path_builder_add_layout" });
        const ret = cFn(self, _layout);
        return ret;
    }
    /// method [add_path](https://docs.gtk.org/gsk4/method.PathBuilder.add_path.html)
    pub fn addPath(self: *PathBuilder, _path: *gsk.Path) void {
        const cFn = @extern(*const fn (*PathBuilder, *gsk.Path) callconv(.c) void, .{ .name = "gsk_path_builder_add_path" });
        const ret = cFn(self, _path);
        return ret;
    }
    /// method [add_rect](https://docs.gtk.org/gsk4/method.PathBuilder.add_rect.html)
    pub fn addRect(self: *PathBuilder, _rect: *graphene.Rect) void {
        const cFn = @extern(*const fn (*PathBuilder, *graphene.Rect) callconv(.c) void, .{ .name = "gsk_path_builder_add_rect" });
        const ret = cFn(self, _rect);
        return ret;
    }
    /// method [add_reverse_path](https://docs.gtk.org/gsk4/method.PathBuilder.add_reverse_path.html)
    pub fn addReversePath(self: *PathBuilder, _path: *gsk.Path) void {
        const cFn = @extern(*const fn (*PathBuilder, *gsk.Path) callconv(.c) void, .{ .name = "gsk_path_builder_add_reverse_path" });
        const ret = cFn(self, _path);
        return ret;
    }
    /// method [add_rounded_rect](https://docs.gtk.org/gsk4/method.PathBuilder.add_rounded_rect.html)
    pub fn addRoundedRect(self: *PathBuilder, _rect: *gsk.RoundedRect) void {
        const cFn = @extern(*const fn (*PathBuilder, *gsk.RoundedRect) callconv(.c) void, .{ .name = "gsk_path_builder_add_rounded_rect" });
        const ret = cFn(self, _rect);
        return ret;
    }
    /// method [add_segment](https://docs.gtk.org/gsk4/method.PathBuilder.add_segment.html)
    pub fn addSegment(self: *PathBuilder, _path: *gsk.Path, _start: *gsk.PathPoint, _end: *gsk.PathPoint) void {
        const cFn = @extern(*const fn (*PathBuilder, *gsk.Path, *gsk.PathPoint, *gsk.PathPoint) callconv(.c) void, .{ .name = "gsk_path_builder_add_segment" });
        const ret = cFn(self, _path, _start, _end);
        return ret;
    }
    /// method [arc_to](https://docs.gtk.org/gsk4/method.PathBuilder.arc_to.html)
    pub fn arcTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_arc_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2);
        return ret;
    }
    /// method [close](https://docs.gtk.org/gsk4/method.PathBuilder.close.html)
    pub fn close(self: *PathBuilder) void {
        const cFn = @extern(*const fn (*PathBuilder) callconv(.c) void, .{ .name = "gsk_path_builder_close" });
        const ret = cFn(self);
        return ret;
    }
    /// method [conic_to](https://docs.gtk.org/gsk4/method.PathBuilder.conic_to.html)
    pub fn conicTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32, _weight: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_conic_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2, _weight);
        return ret;
    }
    /// method [cubic_to](https://docs.gtk.org/gsk4/method.PathBuilder.cubic_to.html)
    pub fn cubicTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32, _x3: f32, _y3: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_cubic_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2, _x3, _y3);
        return ret;
    }
    /// method [get_current_point](https://docs.gtk.org/gsk4/method.PathBuilder.get_current_point.html)
    pub fn getCurrentPoint(self: *PathBuilder) *graphene.Point {
        const cFn = @extern(*const fn (*PathBuilder) callconv(.c) *graphene.Point, .{ .name = "gsk_path_builder_get_current_point" });
        const ret = cFn(self);
        return ret;
    }
    /// method [html_arc_to](https://docs.gtk.org/gsk4/method.PathBuilder.html_arc_to.html)
    pub fn htmlArcTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32, _radius: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_html_arc_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2, _radius);
        return ret;
    }
    /// method [line_to](https://docs.gtk.org/gsk4/method.PathBuilder.line_to.html)
    pub fn lineTo(self: *PathBuilder, _x: f32, _y: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_line_to" });
        const ret = cFn(self, _x, _y);
        return ret;
    }
    /// method [move_to](https://docs.gtk.org/gsk4/method.PathBuilder.move_to.html)
    pub fn moveTo(self: *PathBuilder, _x: f32, _y: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_move_to" });
        const ret = cFn(self, _x, _y);
        return ret;
    }
    /// method [quad_to](https://docs.gtk.org/gsk4/method.PathBuilder.quad_to.html)
    pub fn quadTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_quad_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2);
        return ret;
    }
    /// method [ref](https://docs.gtk.org/gsk4/method.PathBuilder.ref.html)
    pub fn ref(self: *PathBuilder) *gsk.PathBuilder {
        const cFn = @extern(*const fn (*PathBuilder) callconv(.c) *gsk.PathBuilder, .{ .name = "gsk_path_builder_ref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [rel_arc_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_arc_to.html)
    pub fn relArcTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_arc_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2);
        return ret;
    }
    /// method [rel_conic_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_conic_to.html)
    pub fn relConicTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32, _weight: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_conic_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2, _weight);
        return ret;
    }
    /// method [rel_cubic_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_cubic_to.html)
    pub fn relCubicTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32, _x3: f32, _y3: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_cubic_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2, _x3, _y3);
        return ret;
    }
    /// method [rel_html_arc_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_html_arc_to.html)
    pub fn relHtmlArcTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32, _radius: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_html_arc_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2, _radius);
        return ret;
    }
    /// method [rel_line_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_line_to.html)
    pub fn relLineTo(self: *PathBuilder, _x: f32, _y: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_line_to" });
        const ret = cFn(self, _x, _y);
        return ret;
    }
    /// method [rel_move_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_move_to.html)
    pub fn relMoveTo(self: *PathBuilder, _x: f32, _y: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_move_to" });
        const ret = cFn(self, _x, _y);
        return ret;
    }
    /// method [rel_quad_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_quad_to.html)
    pub fn relQuadTo(self: *PathBuilder, _x1: f32, _y1: f32, _x2: f32, _y2: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_quad_to" });
        const ret = cFn(self, _x1, _y1, _x2, _y2);
        return ret;
    }
    /// method [rel_svg_arc_to](https://docs.gtk.org/gsk4/method.PathBuilder.rel_svg_arc_to.html)
    pub fn relSvgArcTo(self: *PathBuilder, _rx: f32, _ry: f32, _x_axis_rotation: f32, _large_arc: bool, _positive_sweep: bool, _x: f32, _y: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, bool, bool, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_rel_svg_arc_to" });
        const ret = cFn(self, _rx, _ry, _x_axis_rotation, _large_arc, _positive_sweep, _x, _y);
        return ret;
    }
    /// method [svg_arc_to](https://docs.gtk.org/gsk4/method.PathBuilder.svg_arc_to.html)
    pub fn svgArcTo(self: *PathBuilder, _rx: f32, _ry: f32, _x_axis_rotation: f32, _large_arc: bool, _positive_sweep: bool, _x: f32, _y: f32) void {
        const cFn = @extern(*const fn (*PathBuilder, f32, f32, f32, bool, bool, f32, f32) callconv(.c) void, .{ .name = "gsk_path_builder_svg_arc_to" });
        const ret = cFn(self, _rx, _ry, _x_axis_rotation, _large_arc, _positive_sweep, _x, _y);
        return ret;
    }
    /// method [to_path](https://docs.gtk.org/gsk4/method.PathBuilder.to_path.html)
    pub fn toPath(self: *PathBuilder) *gsk.Path {
        const cFn = @extern(*const fn (*PathBuilder) callconv(.c) *gsk.Path, .{ .name = "gsk_path_builder_to_path" });
        const ret = cFn(self);
        return ret;
    }
    /// method [unref](https://docs.gtk.org/gsk4/method.PathBuilder.unref.html)
    pub fn unref(self: *PathBuilder) void {
        const cFn = @extern(*const fn (*PathBuilder) callconv(.c) void, .{ .name = "gsk_path_builder_unref" });
        const ret = cFn(self);
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_builder_get_type" });
        return cFn();
    }
};
/// Enum [PathDirection](https://docs.gtk.org/gsk4/enum.PathDirection.html)
pub const PathDirection = enum(u32) {
    from_start = 0,
    to_start = 1,
    to_end = 2,
    from_end = 3,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_direction_get_type" });
        return cFn();
    }
};
/// Flags [PathForeachFlags](https://docs.gtk.org/gsk4/flags.PathForeachFlags.html)
pub const PathForeachFlags = packed struct(u32) {
    quad: bool = false,
    cubic: bool = false,
    conic: bool = false,
    _: u29 = 0,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_foreach_flags_get_type" });
        return cFn();
    }
};
/// callback [PathForeachFunc](https://docs.gtk.org/gsk4/callback.PathForeachFunc.html)
pub const PathForeachFunc = *const fn (_op: gsk.PathOperation, _pts: *graphene.Point, _n_pts: u64, _weight: f32, _user_data: ?*anyopaque) callconv(.c) bool;
/// Struct [PathMeasure](https://docs.gtk.org/gsk4/struct.PathMeasure.html)
pub const PathMeasure = opaque {
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.PathMeasure.new.html)
    pub fn new(_path: *gsk.Path) *PathMeasure {
        const cFn = @extern(*const fn (*gsk.Path) callconv(.c) *PathMeasure, .{ .name = "gsk_path_measure_new" });
        const ret = cFn(_path);
        return ret;
    }
    /// ctor [new_with_tolerance](https://docs.gtk.org/gsk4/ctor.PathMeasure.new_with_tolerance.html)
    pub fn newWithTolerance(_path: *gsk.Path, _tolerance: f32) *PathMeasure {
        const cFn = @extern(*const fn (*gsk.Path, f32) callconv(.c) *PathMeasure, .{ .name = "gsk_path_measure_new_with_tolerance" });
        const ret = cFn(_path, _tolerance);
        return ret;
    }
    /// method [get_length](https://docs.gtk.org/gsk4/method.PathMeasure.get_length.html)
    pub fn getLength(self: *PathMeasure) f32 {
        const cFn = @extern(*const fn (*PathMeasure) callconv(.c) f32, .{ .name = "gsk_path_measure_get_length" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_path](https://docs.gtk.org/gsk4/method.PathMeasure.get_path.html)
    pub fn getPath(self: *PathMeasure) *gsk.Path {
        const cFn = @extern(*const fn (*PathMeasure) callconv(.c) *gsk.Path, .{ .name = "gsk_path_measure_get_path" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_point](https://docs.gtk.org/gsk4/method.PathMeasure.get_point.html)
    pub fn getPoint(self: *PathMeasure, _distance: f32, _result: *gsk.PathPoint) bool {
        const cFn = @extern(*const fn (*PathMeasure, f32, *gsk.PathPoint) callconv(.c) bool, .{ .name = "gsk_path_measure_get_point" });
        const ret = cFn(self, _distance, _result);
        return ret;
    }
    /// method [get_tolerance](https://docs.gtk.org/gsk4/method.PathMeasure.get_tolerance.html)
    pub fn getTolerance(self: *PathMeasure) f32 {
        const cFn = @extern(*const fn (*PathMeasure) callconv(.c) f32, .{ .name = "gsk_path_measure_get_tolerance" });
        const ret = cFn(self);
        return ret;
    }
    /// method [ref](https://docs.gtk.org/gsk4/method.PathMeasure.ref.html)
    pub fn ref(self: *PathMeasure) *gsk.PathMeasure {
        const cFn = @extern(*const fn (*PathMeasure) callconv(.c) *gsk.PathMeasure, .{ .name = "gsk_path_measure_ref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [unref](https://docs.gtk.org/gsk4/method.PathMeasure.unref.html)
    pub fn unref(self: *PathMeasure) void {
        const cFn = @extern(*const fn (*PathMeasure) callconv(.c) void, .{ .name = "gsk_path_measure_unref" });
        const ret = cFn(self);
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_measure_get_type" });
        return cFn();
    }
};
/// Enum [PathOperation](https://docs.gtk.org/gsk4/enum.PathOperation.html)
pub const PathOperation = enum(u32) {
    move = 0,
    close = 1,
    line = 2,
    quad = 3,
    cubic = 4,
    conic = 5,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_operation_get_type" });
        return cFn();
    }
};
/// Struct [PathPoint](https://docs.gtk.org/gsk4/struct.PathPoint.html)
pub const PathPoint = opaque {
    /// method [compare](https://docs.gtk.org/gsk4/method.PathPoint.compare.html)
    pub fn compare(self: *PathPoint, _point2: *gsk.PathPoint) i32 {
        const cFn = @extern(*const fn (*PathPoint, *gsk.PathPoint) callconv(.c) i32, .{ .name = "gsk_path_point_compare" });
        const ret = cFn(self, _point2);
        return ret;
    }
    /// method [copy](https://docs.gtk.org/gsk4/method.PathPoint.copy.html)
    pub fn copy(self: *PathPoint) *gsk.PathPoint {
        const cFn = @extern(*const fn (*PathPoint) callconv(.c) *gsk.PathPoint, .{ .name = "gsk_path_point_copy" });
        const ret = cFn(self);
        return ret;
    }
    /// method [equal](https://docs.gtk.org/gsk4/method.PathPoint.equal.html)
    pub fn equal(self: *PathPoint, _point2: *gsk.PathPoint) bool {
        const cFn = @extern(*const fn (*PathPoint, *gsk.PathPoint) callconv(.c) bool, .{ .name = "gsk_path_point_equal" });
        const ret = cFn(self, _point2);
        return ret;
    }
    /// method [free](https://docs.gtk.org/gsk4/method.PathPoint.free.html)
    pub fn free(self: *PathPoint) void {
        const cFn = @extern(*const fn (*PathPoint) callconv(.c) void, .{ .name = "gsk_path_point_free" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_curvature](https://docs.gtk.org/gsk4/method.PathPoint.get_curvature.html)
    pub fn getCurvature(self: *PathPoint, _path: *gsk.Path, _direction: gsk.PathDirection, _center: *graphene.Point) f32 {
        const cFn = @extern(*const fn (*PathPoint, *gsk.Path, gsk.PathDirection, *graphene.Point) callconv(.c) f32, .{ .name = "gsk_path_point_get_curvature" });
        const ret = cFn(self, _path, _direction, _center);
        return ret;
    }
    /// method [get_distance](https://docs.gtk.org/gsk4/method.PathPoint.get_distance.html)
    pub fn getDistance(self: *PathPoint, _measure: *gsk.PathMeasure) f32 {
        const cFn = @extern(*const fn (*PathPoint, *gsk.PathMeasure) callconv(.c) f32, .{ .name = "gsk_path_point_get_distance" });
        const ret = cFn(self, _measure);
        return ret;
    }
    /// method [get_position](https://docs.gtk.org/gsk4/method.PathPoint.get_position.html)
    pub fn getPosition(self: *PathPoint, _path: *gsk.Path, _position: *graphene.Point) void {
        const cFn = @extern(*const fn (*PathPoint, *gsk.Path, *graphene.Point) callconv(.c) void, .{ .name = "gsk_path_point_get_position" });
        const ret = cFn(self, _path, _position);
        return ret;
    }
    /// method [get_rotation](https://docs.gtk.org/gsk4/method.PathPoint.get_rotation.html)
    pub fn getRotation(self: *PathPoint, _path: *gsk.Path, _direction: gsk.PathDirection) f32 {
        const cFn = @extern(*const fn (*PathPoint, *gsk.Path, gsk.PathDirection) callconv(.c) f32, .{ .name = "gsk_path_point_get_rotation" });
        const ret = cFn(self, _path, _direction);
        return ret;
    }
    /// method [get_tangent](https://docs.gtk.org/gsk4/method.PathPoint.get_tangent.html)
    pub fn getTangent(self: *PathPoint, _path: *gsk.Path, _direction: gsk.PathDirection, _tangent: *graphene.Vec2) void {
        const cFn = @extern(*const fn (*PathPoint, *gsk.Path, gsk.PathDirection, *graphene.Vec2) callconv(.c) void, .{ .name = "gsk_path_point_get_tangent" });
        const ret = cFn(self, _path, _direction, _tangent);
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_path_point_get_type" });
        return cFn();
    }
};
/// Class [RadialGradientNode](https://docs.gtk.org/gsk4/class.RadialGradientNode.html)
pub const RadialGradientNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.RadialGradientNode.new.html)
    pub fn new(_bounds: *graphene.Rect, _center: *graphene.Point, _hradius: f32, _vradius: f32, _start: f32, _end: f32, _color_stopss: []gsk.ColorStop) *RadialGradientNode {
        const _color_stops = _color_stopss.ptr;
        const _n_color_stops: u64 = @intCast(_color_stopss.len);
        const cFn = @extern(*const fn (*graphene.Rect, *graphene.Point, f32, f32, f32, f32, [*]gsk.ColorStop, u64) callconv(.c) *RadialGradientNode, .{ .name = "gsk_radial_gradient_node_new" });
        const ret = cFn(_bounds, _center, _hradius, _vradius, _start, _end, _color_stops, _n_color_stops);
        return ret;
    }
    /// method [get_center](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_center.html)
    pub fn getCenter(self: *RadialGradientNode) *graphene.Point {
        const cFn = @extern(*const fn (*RadialGradientNode) callconv(.c) *graphene.Point, .{ .name = "gsk_radial_gradient_node_get_center" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_color_stops](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_color_stops.html)
    pub fn getColorStops(self: *RadialGradientNode) struct {
        ret: [*]gsk.ColorStop,
        n_stops: u64,
    } {
        var n_stops_out: u64 = undefined;
        const _n_stops = &n_stops_out;
        const cFn = @extern(*const fn (*RadialGradientNode, ?*u64) callconv(.c) [*]gsk.ColorStop, .{ .name = "gsk_radial_gradient_node_get_color_stops" });
        const ret = cFn(self, _n_stops);
        return .{ .ret = ret, .n_stops = n_stops_out };
    }
    /// method [get_end](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_end.html)
    pub fn getEnd(self: *RadialGradientNode) f32 {
        const cFn = @extern(*const fn (*RadialGradientNode) callconv(.c) f32, .{ .name = "gsk_radial_gradient_node_get_end" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_hradius](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_hradius.html)
    pub fn getHradius(self: *RadialGradientNode) f32 {
        const cFn = @extern(*const fn (*RadialGradientNode) callconv(.c) f32, .{ .name = "gsk_radial_gradient_node_get_hradius" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_n_color_stops](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_n_color_stops.html)
    pub fn getNColorStops(self: *RadialGradientNode) u64 {
        const cFn = @extern(*const fn (*RadialGradientNode) callconv(.c) u64, .{ .name = "gsk_radial_gradient_node_get_n_color_stops" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_start](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_start.html)
    pub fn getStart(self: *RadialGradientNode) f32 {
        const cFn = @extern(*const fn (*RadialGradientNode) callconv(.c) f32, .{ .name = "gsk_radial_gradient_node_get_start" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_vradius](https://docs.gtk.org/gsk4/method.RadialGradientNode.get_vradius.html)
    pub fn getVradius(self: *RadialGradientNode) f32 {
        const cFn = @extern(*const fn (*RadialGradientNode) callconv(.c) f32, .{ .name = "gsk_radial_gradient_node_get_vradius" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_radial_gradient_node_get_type" });
        return cFn();
    }
};
/// Class [RenderNode](https://docs.gtk.org/gsk4/class.RenderNode.html)
pub const RenderNode = opaque {
    /// type func [deserialize](https://docs.gtk.org/gsk4/type_func.RenderNode.deserialize.html)
    pub fn deserialize(_bytes: *glib.Bytes, error_func: anytype, error_func_args: anytype) ?*gsk.RenderNode {
        var closure_error_func = core.zig_closure(error_func, error_func_args, &.{ void, *gsk.ParseLocation, *gsk.ParseLocation, *core.Error });
        defer closure_error_func.deinit();
        const _error_func: ?gsk.ParseErrorFunc = @ptrCast(closure_error_func.c_closure());
        const _user_data: ?*anyopaque = @ptrCast(closure_error_func.c_data());
        const cFn = @extern(*const fn (*glib.Bytes, ?gsk.ParseErrorFunc, ?*anyopaque) callconv(.c) ?*gsk.RenderNode, .{ .name = "gsk_render_node_deserialize" });
        const ret = cFn(_bytes, _error_func, @ptrCast(_user_data));
        return ret;
    }
    /// method [draw](https://docs.gtk.org/gsk4/method.RenderNode.draw.html)
    pub fn draw(self: *RenderNode, _cr: *cairo.Context) void {
        const cFn = @extern(*const fn (*RenderNode, *cairo.Context) callconv(.c) void, .{ .name = "gsk_render_node_draw" });
        const ret = cFn(self, _cr);
        return ret;
    }
    /// method [get_bounds](https://docs.gtk.org/gsk4/method.RenderNode.get_bounds.html)
    pub fn getBounds(self: *RenderNode, _bounds: *graphene.Rect) void {
        const cFn = @extern(*const fn (*RenderNode, *graphene.Rect) callconv(.c) void, .{ .name = "gsk_render_node_get_bounds" });
        const ret = cFn(self, _bounds);
        return ret;
    }
    /// method [get_node_type](https://docs.gtk.org/gsk4/method.RenderNode.get_node_type.html)
    pub fn getNodeType(self: *RenderNode) gsk.RenderNodeType {
        const cFn = @extern(*const fn (*RenderNode) callconv(.c) gsk.RenderNodeType, .{ .name = "gsk_render_node_get_node_type" });
        const ret = cFn(self);
        return ret;
    }
    /// method [ref](https://docs.gtk.org/gsk4/method.RenderNode.ref.html)
    pub fn ref(self: *RenderNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*RenderNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_render_node_ref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [serialize](https://docs.gtk.org/gsk4/method.RenderNode.serialize.html)
    pub fn serialize(self: *RenderNode) *glib.Bytes {
        const cFn = @extern(*const fn (*RenderNode) callconv(.c) *glib.Bytes, .{ .name = "gsk_render_node_serialize" });
        const ret = cFn(self);
        return ret;
    }
    /// method [unref](https://docs.gtk.org/gsk4/method.RenderNode.unref.html)
    pub fn unref(self: *RenderNode) void {
        const cFn = @extern(*const fn (*RenderNode) callconv(.c) void, .{ .name = "gsk_render_node_unref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [write_to_file](https://docs.gtk.org/gsk4/method.RenderNode.write_to_file.html)
    pub fn writeToFile(self: *RenderNode, _filename: [*:0]const u8, _error: *?*core.Error) error{GError}!bool {
        const cFn = @extern(*const fn (*RenderNode, [*:0]const u8, *?*core.Error) callconv(.c) bool, .{ .name = "gsk_render_node_write_to_file" });
        const ret = cFn(self, _filename, _error);
        if (_error.* != null) return error.GError;
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_render_node_get_type" });
        return cFn();
    }
};
/// Enum [RenderNodeType](https://docs.gtk.org/gsk4/enum.RenderNodeType.html)
pub const RenderNodeType = enum(u32) {
    not_a_render_node = 0,
    container_node = 1,
    cairo_node = 2,
    color_node = 3,
    linear_gradient_node = 4,
    repeating_linear_gradient_node = 5,
    radial_gradient_node = 6,
    repeating_radial_gradient_node = 7,
    conic_gradient_node = 8,
    border_node = 9,
    texture_node = 10,
    inset_shadow_node = 11,
    outset_shadow_node = 12,
    transform_node = 13,
    opacity_node = 14,
    color_matrix_node = 15,
    repeat_node = 16,
    clip_node = 17,
    rounded_clip_node = 18,
    shadow_node = 19,
    blend_node = 20,
    cross_fade_node = 21,
    text_node = 22,
    blur_node = 23,
    debug_node = 24,
    gl_shader_node = 25,
    texture_scale_node = 26,
    mask_node = 27,
    fill_node = 28,
    stroke_node = 29,
    subsurface_node = 30,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_render_node_type_get_type" });
        return cFn();
    }
};
/// Class [Renderer](https://docs.gtk.org/gsk4/class.Renderer.html)
/// - property [realized](https://docs.gtk.org/gsk4/property.Renderer.realized.html): (r-) `bool`
/// - property [surface](https://docs.gtk.org/gsk4/property.Renderer.surface.html): (r-) `gdk.Surface`
pub const Renderer = opaque {
    pub const Parent = gobject.Object;
    pub const Class = gsk.RendererClass;
    /// ctor [new_for_surface](https://docs.gtk.org/gsk4/ctor.Renderer.new_for_surface.html)
    pub fn newForSurface(_surface: *gdk.Surface) ?*Renderer {
        const cFn = @extern(*const fn (*gdk.Surface) callconv(.c) ?*Renderer, .{ .name = "gsk_renderer_new_for_surface" });
        const ret = cFn(_surface);
        return ret;
    }
    /// method [get_surface](https://docs.gtk.org/gsk4/method.Renderer.get_surface.html)
    pub fn getSurface(self: *Renderer) ?*gdk.Surface {
        const cFn = @extern(*const fn (*Renderer) callconv(.c) ?*gdk.Surface, .{ .name = "gsk_renderer_get_surface" });
        const ret = cFn(self);
        return ret;
    }
    /// method [is_realized](https://docs.gtk.org/gsk4/method.Renderer.is_realized.html)
    pub fn isRealized(self: *Renderer) bool {
        const cFn = @extern(*const fn (*Renderer) callconv(.c) bool, .{ .name = "gsk_renderer_is_realized" });
        const ret = cFn(self);
        return ret;
    }
    /// method [realize](https://docs.gtk.org/gsk4/method.Renderer.realize.html)
    pub fn realize(self: *Renderer, _surface: ?*gdk.Surface, _error: *?*core.Error) error{GError}!bool {
        const cFn = @extern(*const fn (*Renderer, ?*gdk.Surface, *?*core.Error) callconv(.c) bool, .{ .name = "gsk_renderer_realize" });
        const ret = cFn(self, _surface, _error);
        if (_error.* != null) return error.GError;
        return ret;
    }
    /// method [realize_for_display](https://docs.gtk.org/gsk4/method.Renderer.realize_for_display.html)
    pub fn realizeForDisplay(self: *Renderer, _display: *gdk.Display, _error: *?*core.Error) error{GError}!bool {
        const cFn = @extern(*const fn (*Renderer, *gdk.Display, *?*core.Error) callconv(.c) bool, .{ .name = "gsk_renderer_realize_for_display" });
        const ret = cFn(self, _display, _error);
        if (_error.* != null) return error.GError;
        return ret;
    }
    /// method [render](https://docs.gtk.org/gsk4/method.Renderer.render.html)
    pub fn render(self: *Renderer, _root: *gsk.RenderNode, _region: ?*cairo.Region) void {
        const cFn = @extern(*const fn (*Renderer, *gsk.RenderNode, ?*cairo.Region) callconv(.c) void, .{ .name = "gsk_renderer_render" });
        const ret = cFn(self, _root, _region);
        return ret;
    }
    /// method [render_texture](https://docs.gtk.org/gsk4/method.Renderer.render_texture.html)
    pub fn renderTexture(self: *Renderer, _root: *gsk.RenderNode, _viewport: ?*graphene.Rect) *gdk.Texture {
        const cFn = @extern(*const fn (*Renderer, *gsk.RenderNode, ?*graphene.Rect) callconv(.c) *gdk.Texture, .{ .name = "gsk_renderer_render_texture" });
        const ret = cFn(self, _root, _viewport);
        return ret;
    }
    /// method [unrealize](https://docs.gtk.org/gsk4/method.Renderer.unrealize.html)
    pub fn unrealize(self: *Renderer) void {
        const cFn = @extern(*const fn (*Renderer) callconv(.c) void, .{ .name = "gsk_renderer_unrealize" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_renderer_get_type" });
        return cFn();
    }
};
pub const RendererClass = opaque {};
/// Class [RepeatNode](https://docs.gtk.org/gsk4/class.RepeatNode.html)
pub const RepeatNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.RepeatNode.new.html)
    pub fn new(_bounds: *graphene.Rect, _child: *gsk.RenderNode, _child_bounds: ?*graphene.Rect) *RepeatNode {
        const cFn = @extern(*const fn (*graphene.Rect, *gsk.RenderNode, ?*graphene.Rect) callconv(.c) *RepeatNode, .{ .name = "gsk_repeat_node_new" });
        const ret = cFn(_bounds, _child, _child_bounds);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.RepeatNode.get_child.html)
    pub fn getChild(self: *RepeatNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*RepeatNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_repeat_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_child_bounds](https://docs.gtk.org/gsk4/method.RepeatNode.get_child_bounds.html)
    pub fn getChildBounds(self: *RepeatNode) *graphene.Rect {
        const cFn = @extern(*const fn (*RepeatNode) callconv(.c) *graphene.Rect, .{ .name = "gsk_repeat_node_get_child_bounds" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_repeat_node_get_type" });
        return cFn();
    }
};
/// Class [RepeatingLinearGradientNode](https://docs.gtk.org/gsk4/class.RepeatingLinearGradientNode.html)
pub const RepeatingLinearGradientNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.RepeatingLinearGradientNode.new.html)
    pub fn new(_bounds: *graphene.Rect, _start: *graphene.Point, _end: *graphene.Point, _color_stopss: []gsk.ColorStop) *RepeatingLinearGradientNode {
        const _color_stops = _color_stopss.ptr;
        const _n_color_stops: u64 = @intCast(_color_stopss.len);
        const cFn = @extern(*const fn (*graphene.Rect, *graphene.Point, *graphene.Point, [*]gsk.ColorStop, u64) callconv(.c) *RepeatingLinearGradientNode, .{ .name = "gsk_repeating_linear_gradient_node_new" });
        const ret = cFn(_bounds, _start, _end, _color_stops, _n_color_stops);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_repeating_linear_gradient_node_get_type" });
        return cFn();
    }
};
/// Class [RepeatingRadialGradientNode](https://docs.gtk.org/gsk4/class.RepeatingRadialGradientNode.html)
pub const RepeatingRadialGradientNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.RepeatingRadialGradientNode.new.html)
    pub fn new(_bounds: *graphene.Rect, _center: *graphene.Point, _hradius: f32, _vradius: f32, _start: f32, _end: f32, _color_stopss: []gsk.ColorStop) *RepeatingRadialGradientNode {
        const _color_stops = _color_stopss.ptr;
        const _n_color_stops: u64 = @intCast(_color_stopss.len);
        const cFn = @extern(*const fn (*graphene.Rect, *graphene.Point, f32, f32, f32, f32, [*]gsk.ColorStop, u64) callconv(.c) *RepeatingRadialGradientNode, .{ .name = "gsk_repeating_radial_gradient_node_new" });
        const ret = cFn(_bounds, _center, _hradius, _vradius, _start, _end, _color_stops, _n_color_stops);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_repeating_radial_gradient_node_get_type" });
        return cFn();
    }
};
/// Class [RoundedClipNode](https://docs.gtk.org/gsk4/class.RoundedClipNode.html)
pub const RoundedClipNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.RoundedClipNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _clip: *gsk.RoundedRect) *RoundedClipNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.RoundedRect) callconv(.c) *RoundedClipNode, .{ .name = "gsk_rounded_clip_node_new" });
        const ret = cFn(_child, _clip);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.RoundedClipNode.get_child.html)
    pub fn getChild(self: *RoundedClipNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*RoundedClipNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_rounded_clip_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_clip](https://docs.gtk.org/gsk4/method.RoundedClipNode.get_clip.html)
    pub fn getClip(self: *RoundedClipNode) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedClipNode) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_clip_node_get_clip" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_rounded_clip_node_get_type" });
        return cFn();
    }
};
/// Struct [RoundedRect](https://docs.gtk.org/gsk4/struct.RoundedRect.html)
pub const RoundedRect = extern struct {
    bounds: graphene.Rect,
    corner: [4]graphene.Size,
    /// method [contains_point](https://docs.gtk.org/gsk4/method.RoundedRect.contains_point.html)
    pub fn containsPoint(self: *RoundedRect, _point: *graphene.Point) bool {
        const cFn = @extern(*const fn (*RoundedRect, *graphene.Point) callconv(.c) bool, .{ .name = "gsk_rounded_rect_contains_point" });
        const ret = cFn(self, _point);
        return ret;
    }
    /// method [contains_rect](https://docs.gtk.org/gsk4/method.RoundedRect.contains_rect.html)
    pub fn containsRect(self: *RoundedRect, _rect: *graphene.Rect) bool {
        const cFn = @extern(*const fn (*RoundedRect, *graphene.Rect) callconv(.c) bool, .{ .name = "gsk_rounded_rect_contains_rect" });
        const ret = cFn(self, _rect);
        return ret;
    }
    /// method [init](https://docs.gtk.org/gsk4/method.RoundedRect.init.html)
    pub fn init(self: *RoundedRect, _bounds: *graphene.Rect, _top_left: *graphene.Size, _top_right: *graphene.Size, _bottom_right: *graphene.Size, _bottom_left: *graphene.Size) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedRect, *graphene.Rect, *graphene.Size, *graphene.Size, *graphene.Size, *graphene.Size) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_rect_init" });
        const ret = cFn(self, _bounds, _top_left, _top_right, _bottom_right, _bottom_left);
        return ret;
    }
    /// method [init_copy](https://docs.gtk.org/gsk4/method.RoundedRect.init_copy.html)
    pub fn initCopy(self: *RoundedRect, _src: *gsk.RoundedRect) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedRect, *gsk.RoundedRect) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_rect_init_copy" });
        const ret = cFn(self, _src);
        return ret;
    }
    /// method [init_from_rect](https://docs.gtk.org/gsk4/method.RoundedRect.init_from_rect.html)
    pub fn initFromRect(self: *RoundedRect, _bounds: *graphene.Rect, _radius: f32) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedRect, *graphene.Rect, f32) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_rect_init_from_rect" });
        const ret = cFn(self, _bounds, _radius);
        return ret;
    }
    /// method [intersects_rect](https://docs.gtk.org/gsk4/method.RoundedRect.intersects_rect.html)
    pub fn intersectsRect(self: *RoundedRect, _rect: *graphene.Rect) bool {
        const cFn = @extern(*const fn (*RoundedRect, *graphene.Rect) callconv(.c) bool, .{ .name = "gsk_rounded_rect_intersects_rect" });
        const ret = cFn(self, _rect);
        return ret;
    }
    /// method [is_rectilinear](https://docs.gtk.org/gsk4/method.RoundedRect.is_rectilinear.html)
    pub fn isRectilinear(self: *RoundedRect) bool {
        const cFn = @extern(*const fn (*RoundedRect) callconv(.c) bool, .{ .name = "gsk_rounded_rect_is_rectilinear" });
        const ret = cFn(self);
        return ret;
    }
    /// method [normalize](https://docs.gtk.org/gsk4/method.RoundedRect.normalize.html)
    pub fn normalize(self: *RoundedRect) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedRect) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_rect_normalize" });
        const ret = cFn(self);
        return ret;
    }
    /// method [offset](https://docs.gtk.org/gsk4/method.RoundedRect.offset.html)
    pub fn offset(self: *RoundedRect, _dx: f32, _dy: f32) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedRect, f32, f32) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_rect_offset" });
        const ret = cFn(self, _dx, _dy);
        return ret;
    }
    /// method [shrink](https://docs.gtk.org/gsk4/method.RoundedRect.shrink.html)
    pub fn shrink(self: *RoundedRect, _top: f32, _right: f32, _bottom: f32, _left: f32) *gsk.RoundedRect {
        const cFn = @extern(*const fn (*RoundedRect, f32, f32, f32, f32) callconv(.c) *gsk.RoundedRect, .{ .name = "gsk_rounded_rect_shrink" });
        const ret = cFn(self, _top, _right, _bottom, _left);
        return ret;
    }
};
/// Enum [ScalingFilter](https://docs.gtk.org/gsk4/enum.ScalingFilter.html)
pub const ScalingFilter = enum(u32) {
    linear = 0,
    nearest = 1,
    trilinear = 2,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_scaling_filter_get_type" });
        return cFn();
    }
};
/// Error [SerializationError](https://docs.gtk.org/gsk4/error.SerializationError.html)
pub const SerializationError = enum(u32) {
    unsupported_format = 0,
    unsupported_version = 1,
    invalid_data = 2,

    /// type func [quark](https://docs.gtk.org/gsk4/type_func.SerializationError.quark.html)
    pub fn quark() u32 {
        const cFn = @extern(*const fn () callconv(.c) u32, .{ .name = "gsk_serialization_error_quark" });
        const ret = cFn();
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_serialization_error_get_type" });
        return cFn();
    }
};
/// Struct [ShaderArgsBuilder](https://docs.gtk.org/gsk4/struct.ShaderArgsBuilder.html)
pub const ShaderArgsBuilder = opaque {
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ShaderArgsBuilder.new.html)
    pub fn new(_shader: *gsk.GLShader, _initial_values: ?*glib.Bytes) *ShaderArgsBuilder {
        const cFn = @extern(*const fn (*gsk.GLShader, ?*glib.Bytes) callconv(.c) *ShaderArgsBuilder, .{ .name = "gsk_shader_args_builder_new" });
        const ret = cFn(_shader, _initial_values);
        return ret;
    }
    /// method [ref](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.ref.html)
    pub fn ref(self: *ShaderArgsBuilder) *gsk.ShaderArgsBuilder {
        const cFn = @extern(*const fn (*ShaderArgsBuilder) callconv(.c) *gsk.ShaderArgsBuilder, .{ .name = "gsk_shader_args_builder_ref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [set_bool](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_bool.html)
    pub fn setBool(self: *ShaderArgsBuilder, _idx: i32, _value: bool) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, bool) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_bool" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [set_float](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_float.html)
    pub fn setFloat(self: *ShaderArgsBuilder, _idx: i32, _value: f32) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, f32) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_float" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [set_int](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_int.html)
    pub fn setInt(self: *ShaderArgsBuilder, _idx: i32, _value: i32) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, i32) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_int" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [set_uint](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_uint.html)
    pub fn setUint(self: *ShaderArgsBuilder, _idx: i32, _value: u32) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, u32) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_uint" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [set_vec2](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_vec2.html)
    pub fn setVec2(self: *ShaderArgsBuilder, _idx: i32, _value: *graphene.Vec2) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, *graphene.Vec2) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_vec2" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [set_vec3](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_vec3.html)
    pub fn setVec3(self: *ShaderArgsBuilder, _idx: i32, _value: *graphene.Vec3) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, *graphene.Vec3) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_vec3" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [set_vec4](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.set_vec4.html)
    pub fn setVec4(self: *ShaderArgsBuilder, _idx: i32, _value: *graphene.Vec4) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder, i32, *graphene.Vec4) callconv(.c) void, .{ .name = "gsk_shader_args_builder_set_vec4" });
        const ret = cFn(self, _idx, _value);
        return ret;
    }
    /// method [to_args](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.to_args.html)
    pub fn toArgs(self: *ShaderArgsBuilder) *glib.Bytes {
        const cFn = @extern(*const fn (*ShaderArgsBuilder) callconv(.c) *glib.Bytes, .{ .name = "gsk_shader_args_builder_to_args" });
        const ret = cFn(self);
        return ret;
    }
    /// method [unref](https://docs.gtk.org/gsk4/method.ShaderArgsBuilder.unref.html)
    pub fn unref(self: *ShaderArgsBuilder) void {
        const cFn = @extern(*const fn (*ShaderArgsBuilder) callconv(.c) void, .{ .name = "gsk_shader_args_builder_unref" });
        const ret = cFn(self);
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_shader_args_builder_get_type" });
        return cFn();
    }
};
/// Struct [Shadow](https://docs.gtk.org/gsk4/struct.Shadow.html)
pub const Shadow = extern struct {
    color: gdk.RGBA,
    dx: f32,
    dy: f32,
    radius: f32,
};
/// Class [ShadowNode](https://docs.gtk.org/gsk4/class.ShadowNode.html)
pub const ShadowNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.ShadowNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _shadowss: []gsk.Shadow) *ShadowNode {
        const _shadows = _shadowss.ptr;
        const _n_shadows: u64 = @intCast(_shadowss.len);
        const cFn = @extern(*const fn (*gsk.RenderNode, [*]gsk.Shadow, u64) callconv(.c) *ShadowNode, .{ .name = "gsk_shadow_node_new" });
        const ret = cFn(_child, _shadows, _n_shadows);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.ShadowNode.get_child.html)
    pub fn getChild(self: *ShadowNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*ShadowNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_shadow_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_n_shadows](https://docs.gtk.org/gsk4/method.ShadowNode.get_n_shadows.html)
    pub fn getNShadows(self: *ShadowNode) u64 {
        const cFn = @extern(*const fn (*ShadowNode) callconv(.c) u64, .{ .name = "gsk_shadow_node_get_n_shadows" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_shadow](https://docs.gtk.org/gsk4/method.ShadowNode.get_shadow.html)
    pub fn getShadow(self: *ShadowNode, _i: u64) *gsk.Shadow {
        const cFn = @extern(*const fn (*ShadowNode, u64) callconv(.c) *gsk.Shadow, .{ .name = "gsk_shadow_node_get_shadow" });
        const ret = cFn(self, _i);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_shadow_node_get_type" });
        return cFn();
    }
};
/// Struct [Stroke](https://docs.gtk.org/gsk4/struct.Stroke.html)
pub const Stroke = opaque {
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.Stroke.new.html)
    pub fn new(_line_width: f32) *Stroke {
        const cFn = @extern(*const fn (f32) callconv(.c) *Stroke, .{ .name = "gsk_stroke_new" });
        const ret = cFn(_line_width);
        return ret;
    }
    /// method [copy](https://docs.gtk.org/gsk4/method.Stroke.copy.html)
    pub fn copy(self: *Stroke) *gsk.Stroke {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) *gsk.Stroke, .{ .name = "gsk_stroke_copy" });
        const ret = cFn(self);
        return ret;
    }
    /// method [free](https://docs.gtk.org/gsk4/method.Stroke.free.html)
    pub fn free(self: *Stroke) void {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) void, .{ .name = "gsk_stroke_free" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_dash](https://docs.gtk.org/gsk4/method.Stroke.get_dash.html)
    pub fn getDash(self: *Stroke) struct {
        ret: ?[*]f32,
        n_dash: u64,
    } {
        var n_dash_out: u64 = undefined;
        const _n_dash = &n_dash_out;
        const cFn = @extern(*const fn (*Stroke, *u64) callconv(.c) ?[*]f32, .{ .name = "gsk_stroke_get_dash" });
        const ret = cFn(self, _n_dash);
        return .{ .ret = ret, .n_dash = n_dash_out };
    }
    /// method [get_dash_offset](https://docs.gtk.org/gsk4/method.Stroke.get_dash_offset.html)
    pub fn getDashOffset(self: *Stroke) f32 {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) f32, .{ .name = "gsk_stroke_get_dash_offset" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_line_cap](https://docs.gtk.org/gsk4/method.Stroke.get_line_cap.html)
    pub fn getLineCap(self: *Stroke) gsk.LineCap {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) gsk.LineCap, .{ .name = "gsk_stroke_get_line_cap" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_line_join](https://docs.gtk.org/gsk4/method.Stroke.get_line_join.html)
    pub fn getLineJoin(self: *Stroke) gsk.LineJoin {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) gsk.LineJoin, .{ .name = "gsk_stroke_get_line_join" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_line_width](https://docs.gtk.org/gsk4/method.Stroke.get_line_width.html)
    pub fn getLineWidth(self: *Stroke) f32 {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) f32, .{ .name = "gsk_stroke_get_line_width" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_miter_limit](https://docs.gtk.org/gsk4/method.Stroke.get_miter_limit.html)
    pub fn getMiterLimit(self: *Stroke) f32 {
        const cFn = @extern(*const fn (*Stroke) callconv(.c) f32, .{ .name = "gsk_stroke_get_miter_limit" });
        const ret = cFn(self);
        return ret;
    }
    /// method [set_dash](https://docs.gtk.org/gsk4/method.Stroke.set_dash.html)
    pub fn setDash(self: *Stroke, _dashs: []f32) void {
        const _dash = _dashs.ptr;
        const _n_dash: u64 = @intCast(_dashs.len);
        const cFn = @extern(*const fn (*Stroke, ?[*]f32, u64) callconv(.c) void, .{ .name = "gsk_stroke_set_dash" });
        const ret = cFn(self, _dash, _n_dash);
        return ret;
    }
    /// method [set_dash_offset](https://docs.gtk.org/gsk4/method.Stroke.set_dash_offset.html)
    pub fn setDashOffset(self: *Stroke, _offset: f32) void {
        const cFn = @extern(*const fn (*Stroke, f32) callconv(.c) void, .{ .name = "gsk_stroke_set_dash_offset" });
        const ret = cFn(self, _offset);
        return ret;
    }
    /// method [set_line_cap](https://docs.gtk.org/gsk4/method.Stroke.set_line_cap.html)
    pub fn setLineCap(self: *Stroke, _line_cap: gsk.LineCap) void {
        const cFn = @extern(*const fn (*Stroke, gsk.LineCap) callconv(.c) void, .{ .name = "gsk_stroke_set_line_cap" });
        const ret = cFn(self, _line_cap);
        return ret;
    }
    /// method [set_line_join](https://docs.gtk.org/gsk4/method.Stroke.set_line_join.html)
    pub fn setLineJoin(self: *Stroke, _line_join: gsk.LineJoin) void {
        const cFn = @extern(*const fn (*Stroke, gsk.LineJoin) callconv(.c) void, .{ .name = "gsk_stroke_set_line_join" });
        const ret = cFn(self, _line_join);
        return ret;
    }
    /// method [set_line_width](https://docs.gtk.org/gsk4/method.Stroke.set_line_width.html)
    pub fn setLineWidth(self: *Stroke, _line_width: f32) void {
        const cFn = @extern(*const fn (*Stroke, f32) callconv(.c) void, .{ .name = "gsk_stroke_set_line_width" });
        const ret = cFn(self, _line_width);
        return ret;
    }
    /// method [set_miter_limit](https://docs.gtk.org/gsk4/method.Stroke.set_miter_limit.html)
    pub fn setMiterLimit(self: *Stroke, _limit: f32) void {
        const cFn = @extern(*const fn (*Stroke, f32) callconv(.c) void, .{ .name = "gsk_stroke_set_miter_limit" });
        const ret = cFn(self, _limit);
        return ret;
    }
    /// method [to_cairo](https://docs.gtk.org/gsk4/method.Stroke.to_cairo.html)
    pub fn toCairo(self: *Stroke, _cr: *cairo.Context) void {
        const cFn = @extern(*const fn (*Stroke, *cairo.Context) callconv(.c) void, .{ .name = "gsk_stroke_to_cairo" });
        const ret = cFn(self, _cr);
        return ret;
    }
    /// type func [equal](https://docs.gtk.org/gsk4/type_func.Stroke.equal.html)
    pub fn equal(_stroke1: ?*anyopaque, _stroke2: ?*anyopaque) bool {
        const cFn = @extern(*const fn (?*anyopaque, ?*anyopaque) callconv(.c) bool, .{ .name = "gsk_stroke_equal" });
        const ret = cFn(@ptrCast(_stroke1), @ptrCast(_stroke2));
        return ret;
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_stroke_get_type" });
        return cFn();
    }
};
/// Class [StrokeNode](https://docs.gtk.org/gsk4/class.StrokeNode.html)
pub const StrokeNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.StrokeNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _path: *gsk.Path, _stroke: *gsk.Stroke) *StrokeNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.Path, *gsk.Stroke) callconv(.c) *StrokeNode, .{ .name = "gsk_stroke_node_new" });
        const ret = cFn(_child, _path, _stroke);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.StrokeNode.get_child.html)
    pub fn getChild(self: *StrokeNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*StrokeNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_stroke_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_path](https://docs.gtk.org/gsk4/method.StrokeNode.get_path.html)
    pub fn getPath(self: *StrokeNode) *gsk.Path {
        const cFn = @extern(*const fn (*StrokeNode) callconv(.c) *gsk.Path, .{ .name = "gsk_stroke_node_get_path" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_stroke](https://docs.gtk.org/gsk4/method.StrokeNode.get_stroke.html)
    pub fn getStroke(self: *StrokeNode) *gsk.Stroke {
        const cFn = @extern(*const fn (*StrokeNode) callconv(.c) *gsk.Stroke, .{ .name = "gsk_stroke_node_get_stroke" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_stroke_node_get_type" });
        return cFn();
    }
};
/// Class [SubsurfaceNode](https://docs.gtk.org/gsk4/class.SubsurfaceNode.html)
pub const SubsurfaceNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// method [get_child](https://docs.gtk.org/gsk4/method.SubsurfaceNode.get_child.html)
    pub fn getChild(self: *SubsurfaceNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*SubsurfaceNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_subsurface_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_subsurface_node_get_type" });
        return cFn();
    }
};
/// Class [TextNode](https://docs.gtk.org/gsk4/class.TextNode.html)
pub const TextNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.TextNode.new.html)
    pub fn new(_font: *pango.Font, _glyphs: *pango.GlyphString, _color: *gdk.RGBA, _offset: *graphene.Point) ?*TextNode {
        const cFn = @extern(*const fn (*pango.Font, *pango.GlyphString, *gdk.RGBA, *graphene.Point) callconv(.c) ?*TextNode, .{ .name = "gsk_text_node_new" });
        const ret = cFn(_font, _glyphs, _color, _offset);
        return ret;
    }
    /// method [get_color](https://docs.gtk.org/gsk4/method.TextNode.get_color.html)
    pub fn getColor(self: *TextNode) *gdk.RGBA {
        const cFn = @extern(*const fn (*TextNode) callconv(.c) *gdk.RGBA, .{ .name = "gsk_text_node_get_color" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_font](https://docs.gtk.org/gsk4/method.TextNode.get_font.html)
    pub fn getFont(self: *TextNode) *pango.Font {
        const cFn = @extern(*const fn (*TextNode) callconv(.c) *pango.Font, .{ .name = "gsk_text_node_get_font" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_glyphs](https://docs.gtk.org/gsk4/method.TextNode.get_glyphs.html)
    pub fn getGlyphs(self: *TextNode) struct {
        ret: [*]pango.GlyphInfo,
        n_glyphs: u32,
    } {
        var n_glyphs_out: u32 = undefined;
        const _n_glyphs = &n_glyphs_out;
        const cFn = @extern(*const fn (*TextNode, ?*u32) callconv(.c) [*]pango.GlyphInfo, .{ .name = "gsk_text_node_get_glyphs" });
        const ret = cFn(self, _n_glyphs);
        return .{ .ret = ret, .n_glyphs = n_glyphs_out };
    }
    /// method [get_num_glyphs](https://docs.gtk.org/gsk4/method.TextNode.get_num_glyphs.html)
    pub fn getNumGlyphs(self: *TextNode) u32 {
        const cFn = @extern(*const fn (*TextNode) callconv(.c) u32, .{ .name = "gsk_text_node_get_num_glyphs" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_offset](https://docs.gtk.org/gsk4/method.TextNode.get_offset.html)
    pub fn getOffset(self: *TextNode) *graphene.Point {
        const cFn = @extern(*const fn (*TextNode) callconv(.c) *graphene.Point, .{ .name = "gsk_text_node_get_offset" });
        const ret = cFn(self);
        return ret;
    }
    /// method [has_color_glyphs](https://docs.gtk.org/gsk4/method.TextNode.has_color_glyphs.html)
    pub fn hasColorGlyphs(self: *TextNode) bool {
        const cFn = @extern(*const fn (*TextNode) callconv(.c) bool, .{ .name = "gsk_text_node_has_color_glyphs" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_text_node_get_type" });
        return cFn();
    }
};
/// Class [TextureNode](https://docs.gtk.org/gsk4/class.TextureNode.html)
pub const TextureNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.TextureNode.new.html)
    pub fn new(_texture: *gdk.Texture, _bounds: *graphene.Rect) *TextureNode {
        const cFn = @extern(*const fn (*gdk.Texture, *graphene.Rect) callconv(.c) *TextureNode, .{ .name = "gsk_texture_node_new" });
        const ret = cFn(_texture, _bounds);
        return ret;
    }
    /// method [get_texture](https://docs.gtk.org/gsk4/method.TextureNode.get_texture.html)
    pub fn getTexture(self: *TextureNode) *gdk.Texture {
        const cFn = @extern(*const fn (*TextureNode) callconv(.c) *gdk.Texture, .{ .name = "gsk_texture_node_get_texture" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_texture_node_get_type" });
        return cFn();
    }
};
/// Class [TextureScaleNode](https://docs.gtk.org/gsk4/class.TextureScaleNode.html)
pub const TextureScaleNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.TextureScaleNode.new.html)
    pub fn new(_texture: *gdk.Texture, _bounds: *graphene.Rect, _filter: gsk.ScalingFilter) *TextureScaleNode {
        const cFn = @extern(*const fn (*gdk.Texture, *graphene.Rect, gsk.ScalingFilter) callconv(.c) *TextureScaleNode, .{ .name = "gsk_texture_scale_node_new" });
        const ret = cFn(_texture, _bounds, _filter);
        return ret;
    }
    /// method [get_filter](https://docs.gtk.org/gsk4/method.TextureScaleNode.get_filter.html)
    pub fn getFilter(self: *TextureScaleNode) gsk.ScalingFilter {
        const cFn = @extern(*const fn (*TextureScaleNode) callconv(.c) gsk.ScalingFilter, .{ .name = "gsk_texture_scale_node_get_filter" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_texture](https://docs.gtk.org/gsk4/method.TextureScaleNode.get_texture.html)
    pub fn getTexture(self: *TextureScaleNode) *gdk.Texture {
        const cFn = @extern(*const fn (*TextureScaleNode) callconv(.c) *gdk.Texture, .{ .name = "gsk_texture_scale_node_get_texture" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_texture_scale_node_get_type" });
        return cFn();
    }
};
/// Struct [Transform](https://docs.gtk.org/gsk4/struct.Transform.html)
pub const Transform = opaque {
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.Transform.new.html)
    pub fn new() *Transform {
        const cFn = @extern(*const fn () callconv(.c) *Transform, .{ .name = "gsk_transform_new" });
        const ret = cFn();
        return ret;
    }
    /// method [equal](https://docs.gtk.org/gsk4/method.Transform.equal.html)
    pub fn equal(self: *Transform, _second: ?*gsk.Transform) bool {
        const cFn = @extern(*const fn (*Transform, ?*gsk.Transform) callconv(.c) bool, .{ .name = "gsk_transform_equal" });
        const ret = cFn(self, _second);
        return ret;
    }
    /// method [get_category](https://docs.gtk.org/gsk4/method.Transform.get_category.html)
    pub fn getCategory(self: *Transform) gsk.TransformCategory {
        const cFn = @extern(*const fn (*Transform) callconv(.c) gsk.TransformCategory, .{ .name = "gsk_transform_get_category" });
        const ret = cFn(self);
        return ret;
    }
    /// method [invert](https://docs.gtk.org/gsk4/method.Transform.invert.html)
    pub fn invert(self: *Transform) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_invert" });
        const ret = cFn(self);
        return ret;
    }
    /// method [matrix](https://docs.gtk.org/gsk4/method.Transform.matrix.html)
    pub fn matrix(self: *Transform, _matrix: *graphene.Matrix) *gsk.Transform {
        const cFn = @extern(*const fn (*Transform, *graphene.Matrix) callconv(.c) *gsk.Transform, .{ .name = "gsk_transform_matrix" });
        const ret = cFn(self, _matrix);
        return ret;
    }
    /// method [perspective](https://docs.gtk.org/gsk4/method.Transform.perspective.html)
    pub fn perspective(self: *Transform, _depth: f32) *gsk.Transform {
        const cFn = @extern(*const fn (*Transform, f32) callconv(.c) *gsk.Transform, .{ .name = "gsk_transform_perspective" });
        const ret = cFn(self, _depth);
        return ret;
    }
    /// method [print](https://docs.gtk.org/gsk4/method.Transform.print.html)
    pub fn print(self: *Transform, _string: *glib.String) void {
        const cFn = @extern(*const fn (*Transform, *glib.String) callconv(.c) void, .{ .name = "gsk_transform_print" });
        const ret = cFn(self, _string);
        return ret;
    }
    /// method [ref](https://docs.gtk.org/gsk4/method.Transform.ref.html)
    pub fn ref(self: *Transform) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_ref" });
        const ret = cFn(self);
        return ret;
    }
    /// method [rotate](https://docs.gtk.org/gsk4/method.Transform.rotate.html)
    pub fn rotate(self: *Transform, _angle: f32) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, f32) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_rotate" });
        const ret = cFn(self, _angle);
        return ret;
    }
    /// method [rotate_3d](https://docs.gtk.org/gsk4/method.Transform.rotate_3d.html)
    pub fn rotate3d(self: *Transform, _angle: f32, _axis: *graphene.Vec3) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, f32, *graphene.Vec3) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_rotate_3d" });
        const ret = cFn(self, _angle, _axis);
        return ret;
    }
    /// method [scale](https://docs.gtk.org/gsk4/method.Transform.scale.html)
    pub fn scale(self: *Transform, _factor_x: f32, _factor_y: f32) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, f32, f32) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_scale" });
        const ret = cFn(self, _factor_x, _factor_y);
        return ret;
    }
    /// method [scale_3d](https://docs.gtk.org/gsk4/method.Transform.scale_3d.html)
    pub fn scale3d(self: *Transform, _factor_x: f32, _factor_y: f32, _factor_z: f32) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, f32, f32, f32) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_scale_3d" });
        const ret = cFn(self, _factor_x, _factor_y, _factor_z);
        return ret;
    }
    /// method [skew](https://docs.gtk.org/gsk4/method.Transform.skew.html)
    pub fn skew(self: *Transform, _skew_x: f32, _skew_y: f32) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, f32, f32) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_skew" });
        const ret = cFn(self, _skew_x, _skew_y);
        return ret;
    }
    /// method [to_2d](https://docs.gtk.org/gsk4/method.Transform.to_2d.html)
    pub fn to2d(self: *Transform) struct {
        ret: void,
        out_xx: f32,
        out_yx: f32,
        out_xy: f32,
        out_yy: f32,
        out_dx: f32,
        out_dy: f32,
    } {
        var out_xx_out: f32 = undefined;
        const _out_xx = &out_xx_out;
        var out_yx_out: f32 = undefined;
        const _out_yx = &out_yx_out;
        var out_xy_out: f32 = undefined;
        const _out_xy = &out_xy_out;
        var out_yy_out: f32 = undefined;
        const _out_yy = &out_yy_out;
        var out_dx_out: f32 = undefined;
        const _out_dx = &out_dx_out;
        var out_dy_out: f32 = undefined;
        const _out_dy = &out_dy_out;
        const cFn = @extern(*const fn (*Transform, *f32, *f32, *f32, *f32, *f32, *f32) callconv(.c) void, .{ .name = "gsk_transform_to_2d" });
        const ret = cFn(self, _out_xx, _out_yx, _out_xy, _out_yy, _out_dx, _out_dy);
        return .{ .ret = ret, .out_xx = out_xx_out, .out_yx = out_yx_out, .out_xy = out_xy_out, .out_yy = out_yy_out, .out_dx = out_dx_out, .out_dy = out_dy_out };
    }
    /// method [to_2d_components](https://docs.gtk.org/gsk4/method.Transform.to_2d_components.html)
    pub fn to2dComponents(self: *Transform) struct {
        ret: void,
        out_skew_x: f32,
        out_skew_y: f32,
        out_scale_x: f32,
        out_scale_y: f32,
        out_angle: f32,
        out_dx: f32,
        out_dy: f32,
    } {
        var out_skew_x_out: f32 = undefined;
        const _out_skew_x = &out_skew_x_out;
        var out_skew_y_out: f32 = undefined;
        const _out_skew_y = &out_skew_y_out;
        var out_scale_x_out: f32 = undefined;
        const _out_scale_x = &out_scale_x_out;
        var out_scale_y_out: f32 = undefined;
        const _out_scale_y = &out_scale_y_out;
        var out_angle_out: f32 = undefined;
        const _out_angle = &out_angle_out;
        var out_dx_out: f32 = undefined;
        const _out_dx = &out_dx_out;
        var out_dy_out: f32 = undefined;
        const _out_dy = &out_dy_out;
        const cFn = @extern(*const fn (*Transform, *f32, *f32, *f32, *f32, *f32, *f32, *f32) callconv(.c) void, .{ .name = "gsk_transform_to_2d_components" });
        const ret = cFn(self, _out_skew_x, _out_skew_y, _out_scale_x, _out_scale_y, _out_angle, _out_dx, _out_dy);
        return .{ .ret = ret, .out_skew_x = out_skew_x_out, .out_skew_y = out_skew_y_out, .out_scale_x = out_scale_x_out, .out_scale_y = out_scale_y_out, .out_angle = out_angle_out, .out_dx = out_dx_out, .out_dy = out_dy_out };
    }
    /// method [to_affine](https://docs.gtk.org/gsk4/method.Transform.to_affine.html)
    pub fn toAffine(self: *Transform) struct {
        ret: void,
        out_scale_x: f32,
        out_scale_y: f32,
        out_dx: f32,
        out_dy: f32,
    } {
        var out_scale_x_out: f32 = undefined;
        const _out_scale_x = &out_scale_x_out;
        var out_scale_y_out: f32 = undefined;
        const _out_scale_y = &out_scale_y_out;
        var out_dx_out: f32 = undefined;
        const _out_dx = &out_dx_out;
        var out_dy_out: f32 = undefined;
        const _out_dy = &out_dy_out;
        const cFn = @extern(*const fn (*Transform, *f32, *f32, *f32, *f32) callconv(.c) void, .{ .name = "gsk_transform_to_affine" });
        const ret = cFn(self, _out_scale_x, _out_scale_y, _out_dx, _out_dy);
        return .{ .ret = ret, .out_scale_x = out_scale_x_out, .out_scale_y = out_scale_y_out, .out_dx = out_dx_out, .out_dy = out_dy_out };
    }
    /// method [to_matrix](https://docs.gtk.org/gsk4/method.Transform.to_matrix.html)
    pub fn toMatrix(self: *Transform, _out_matrix: *graphene.Matrix) void {
        const cFn = @extern(*const fn (*Transform, *graphene.Matrix) callconv(.c) void, .{ .name = "gsk_transform_to_matrix" });
        const ret = cFn(self, _out_matrix);
        return ret;
    }
    /// method [to_string](https://docs.gtk.org/gsk4/method.Transform.to_string.html)
    pub fn toString(self: *Transform) [*:0]u8 {
        const cFn = @extern(*const fn (*Transform) callconv(.c) [*:0]u8, .{ .name = "gsk_transform_to_string" });
        const ret = cFn(self);
        return ret;
    }
    /// method [to_translate](https://docs.gtk.org/gsk4/method.Transform.to_translate.html)
    pub fn toTranslate(self: *Transform) struct {
        ret: void,
        out_dx: f32,
        out_dy: f32,
    } {
        var out_dx_out: f32 = undefined;
        const _out_dx = &out_dx_out;
        var out_dy_out: f32 = undefined;
        const _out_dy = &out_dy_out;
        const cFn = @extern(*const fn (*Transform, *f32, *f32) callconv(.c) void, .{ .name = "gsk_transform_to_translate" });
        const ret = cFn(self, _out_dx, _out_dy);
        return .{ .ret = ret, .out_dx = out_dx_out, .out_dy = out_dy_out };
    }
    /// method [transform](https://docs.gtk.org/gsk4/method.Transform.transform.html)
    pub fn transform(self: *Transform, _other: ?*gsk.Transform) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, ?*gsk.Transform) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_transform" });
        const ret = cFn(self, _other);
        return ret;
    }
    /// method [transform_bounds](https://docs.gtk.org/gsk4/method.Transform.transform_bounds.html)
    pub fn transformBounds(self: *Transform, _rect: *graphene.Rect, _out_rect: *graphene.Rect) void {
        const cFn = @extern(*const fn (*Transform, *graphene.Rect, *graphene.Rect) callconv(.c) void, .{ .name = "gsk_transform_transform_bounds" });
        const ret = cFn(self, _rect, _out_rect);
        return ret;
    }
    /// method [transform_point](https://docs.gtk.org/gsk4/method.Transform.transform_point.html)
    pub fn transformPoint(self: *Transform, _point: *graphene.Point, _out_point: *graphene.Point) void {
        const cFn = @extern(*const fn (*Transform, *graphene.Point, *graphene.Point) callconv(.c) void, .{ .name = "gsk_transform_transform_point" });
        const ret = cFn(self, _point, _out_point);
        return ret;
    }
    /// method [translate](https://docs.gtk.org/gsk4/method.Transform.translate.html)
    pub fn translate(self: *Transform, _point: *graphene.Point) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, *graphene.Point) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_translate" });
        const ret = cFn(self, _point);
        return ret;
    }
    /// method [translate_3d](https://docs.gtk.org/gsk4/method.Transform.translate_3d.html)
    pub fn translate3d(self: *Transform, _point: *graphene.Point3D) ?*gsk.Transform {
        const cFn = @extern(*const fn (*Transform, *graphene.Point3D) callconv(.c) ?*gsk.Transform, .{ .name = "gsk_transform_translate_3d" });
        const ret = cFn(self, _point);
        return ret;
    }
    /// method [unref](https://docs.gtk.org/gsk4/method.Transform.unref.html)
    pub fn unref(self: *Transform) void {
        const cFn = @extern(*const fn (*Transform) callconv(.c) void, .{ .name = "gsk_transform_unref" });
        const ret = cFn(self);
        return ret;
    }
    /// type func [parse](https://docs.gtk.org/gsk4/type_func.Transform.parse.html)
    pub fn parse(_string: [*:0]const u8) struct {
        ret: bool,
        out_transform: *gsk.Transform,
    } {
        var out_transform_out: *gsk.Transform = undefined;
        const _out_transform = &out_transform_out;
        const cFn = @extern(*const fn ([*:0]const u8, **gsk.Transform) callconv(.c) bool, .{ .name = "gsk_transform_parse" });
        const ret = cFn(_string, _out_transform);
        return .{ .ret = ret, .out_transform = out_transform_out };
    }
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_transform_get_type" });
        return cFn();
    }
};
/// Enum [TransformCategory](https://docs.gtk.org/gsk4/enum.TransformCategory.html)
pub const TransformCategory = enum(u32) {
    unknown = 0,
    any = 1,
    @"3d" = 2,
    @"2d" = 3,
    @"2d_affine" = 4,
    @"2d_translate" = 5,
    identity = 6,
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_transform_category_get_type" });
        return cFn();
    }
};
/// Class [TransformNode](https://docs.gtk.org/gsk4/class.TransformNode.html)
pub const TransformNode = opaque {
    pub const Parent = gsk.RenderNode;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.TransformNode.new.html)
    pub fn new(_child: *gsk.RenderNode, _transform: *gsk.Transform) *TransformNode {
        const cFn = @extern(*const fn (*gsk.RenderNode, *gsk.Transform) callconv(.c) *TransformNode, .{ .name = "gsk_transform_node_new" });
        const ret = cFn(_child, _transform);
        return ret;
    }
    /// method [get_child](https://docs.gtk.org/gsk4/method.TransformNode.get_child.html)
    pub fn getChild(self: *TransformNode) *gsk.RenderNode {
        const cFn = @extern(*const fn (*TransformNode) callconv(.c) *gsk.RenderNode, .{ .name = "gsk_transform_node_get_child" });
        const ret = cFn(self);
        return ret;
    }
    /// method [get_transform](https://docs.gtk.org/gsk4/method.TransformNode.get_transform.html)
    pub fn getTransform(self: *TransformNode) *gsk.Transform {
        const cFn = @extern(*const fn (*TransformNode) callconv(.c) *gsk.Transform, .{ .name = "gsk_transform_node_get_transform" });
        const ret = cFn(self);
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_transform_node_get_type" });
        return cFn();
    }
};
/// Class [VulkanRenderer](https://docs.gtk.org/gsk4/class.VulkanRenderer.html)
pub const VulkanRenderer = opaque {
    pub const Parent = gsk.Renderer;
    pub const Class = gsk.VulkanRendererClass;
    /// ctor [new](https://docs.gtk.org/gsk4/ctor.VulkanRenderer.new.html)
    pub fn new() *VulkanRenderer {
        const cFn = @extern(*const fn () callconv(.c) *VulkanRenderer, .{ .name = "gsk_vulkan_renderer_new" });
        const ret = cFn();
        return ret;
    }
    const Ext = core.Extend(@This());
    pub const __call = Ext.__call;
    pub const into = Ext.into;
    pub const tryInto = Ext.tryInto;
    pub const property = Ext.property;
    pub const signalConnect = Ext.signalConnect;
    pub fn gType() core.Type {
        const cFn = @extern(*const fn () callconv(.c) core.Type, .{ .name = "gsk_vulkan_renderer_get_type" });
        return cFn();
    }
};
pub const VulkanRendererClass = opaque {};
/// func [path_parse](https://docs.gtk.org/gsk4/func.path_parse.html)
pub fn pathParse(_string: [*:0]const u8) ?*gsk.Path {
    const cFn = @extern(*const fn ([*:0]const u8) callconv(.c) ?*gsk.Path, .{ .name = "gsk_path_parse" });
    const ret = cFn(_string);
    return ret;
}
/// func [serialization_error_quark](https://docs.gtk.org/gsk4/func.serialization_error_quark.html)
pub fn serializationErrorQuark() u32 {
    const cFn = @extern(*const fn () callconv(.c) u32, .{ .name = "gsk_serialization_error_quark" });
    const ret = cFn();
    return ret;
}
/// func [stroke_equal](https://docs.gtk.org/gsk4/func.stroke_equal.html)
pub fn strokeEqual(_stroke1: ?*anyopaque, _stroke2: ?*anyopaque) bool {
    const cFn = @extern(*const fn (?*anyopaque, ?*anyopaque) callconv(.c) bool, .{ .name = "gsk_stroke_equal" });
    const ret = cFn(@ptrCast(_stroke1), @ptrCast(_stroke2));
    return ret;
}
/// func [transform_parse](https://docs.gtk.org/gsk4/func.transform_parse.html)
pub fn transformParse(_string: [*:0]const u8) struct {
    ret: bool,
    out_transform: *gsk.Transform,
} {
    var out_transform_out: *gsk.Transform = undefined;
    const _out_transform = &out_transform_out;
    const cFn = @extern(*const fn ([*:0]const u8, **gsk.Transform) callconv(.c) bool, .{ .name = "gsk_transform_parse" });
    const ret = cFn(_string, _out_transform);
    return .{ .ret = ret, .out_transform = out_transform_out };
}
/// func [value_dup_render_node](https://docs.gtk.org/gsk4/func.value_dup_render_node.html)
pub fn valueDupRenderNode(_value: *gobject.Value) ?*gsk.RenderNode {
    const cFn = @extern(*const fn (*gobject.Value) callconv(.c) ?*gsk.RenderNode, .{ .name = "gsk_value_dup_render_node" });
    const ret = cFn(_value);
    return ret;
}
/// func [value_get_render_node](https://docs.gtk.org/gsk4/func.value_get_render_node.html)
pub fn valueGetRenderNode(_value: *gobject.Value) ?*gsk.RenderNode {
    const cFn = @extern(*const fn (*gobject.Value) callconv(.c) ?*gsk.RenderNode, .{ .name = "gsk_value_get_render_node" });
    const ret = cFn(_value);
    return ret;
}
/// func [value_set_render_node](https://docs.gtk.org/gsk4/func.value_set_render_node.html)
pub fn valueSetRenderNode(_value: *gobject.Value, _node: *gsk.RenderNode) void {
    const cFn = @extern(*const fn (*gobject.Value, *gsk.RenderNode) callconv(.c) void, .{ .name = "gsk_value_set_render_node" });
    const ret = cFn(_value, _node);
    return ret;
}
/// func [value_take_render_node](https://docs.gtk.org/gsk4/func.value_take_render_node.html)
pub fn valueTakeRenderNode(_value: *gobject.Value, _node: ?*gsk.RenderNode) void {
    const cFn = @extern(*const fn (*gobject.Value, ?*gsk.RenderNode) callconv(.c) void, .{ .name = "gsk_value_take_render_node" });
    const ret = cFn(_value, _node);
    return ret;
}
test {
    @setEvalBranchQuota(1_000_000);
    std.testing.refAllDecls(@This());
}
